<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pump Foil Simulator (Angle Telemetry)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .canvas-wrapper {
            position: relative;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            pointer-events: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            min-width: 200px;
            z-index: 10;
        }

        #controls {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
            max-width: 950px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 110px;
        }

        label {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
        }

        input[type=range] {
            height: 4px;
        }

        /* LEGEND STYLES */
        .legend-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-left: 15px;
            border-left: 1px solid #eee;
            padding-left: 15px;
        }
        .legend-title {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .legend-items { display: flex; flex-wrap: wrap; gap: 10px; font-size: 11px; }
        .legend-item { display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        input[type=checkbox] { cursor: pointer; }
        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-size: 9px;
            font-weight: 700;
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div class="canvas-wrapper">
            <canvas id="simCanvas" width="900" height="350"></canvas>
            <div id="ui-overlay">
                <strong>Live Telemetry</strong><br>
                Time: <span id="val-time">0.00</span> s<br>
                Speed: <span id="val-speed">18.0</span> km/h<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Pitch (vs Horizon): <span id="val-pitch">0.0</span>°<br>
                AoA (vs Water): <span id="val-aoa">0.0</span>°<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Inst. Power: <span id="val-watts">0</span> W<br>
                Avg. Power: <span id="val-avg-watts">0</span> W
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="graphThrust" width="900" height="140"></canvas>
        </div>
        <div class="canvas-wrapper" id="avgThrustStatus" style="padding: 10px; text-align: center; font-size: 14px; font-weight: bold; background-color: #e8f5e9;">
            Avg Thrust: Accelerating — <span id="val-avg-thrust">0</span> N
        </div>
        <div class="canvas-wrapper">
            <canvas id="graphPower" width="900" height="140"></canvas>
        </div>
        <div class="canvas-wrapper">
            <canvas id="graphAvgPower" width="900" height="140"></canvas>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>Speed: <span id="disp-speed">18.0</span> km/h</label>
                <input type="range" id="in-speed" min="10.0" max="30.0" step="1.0" value="18.0">
            </div>
            <div class="control-group">
                <label>Mass: <span id="disp-mass">80</span> kg</label>
                <input type="range" id="in-mass" min="40" max="120" step="1" value="80">
            </div>
            <div class="control-group">
                <label>Wing Area: <span id="disp-area">1200</span> cm²</label>
                <input type="range" id="in-area" min="600" max="2000" step="50" value="1200">
            </div>
            <div class="control-group">
                <label>Freq: <span id="disp-freq">1.5</span> Hz</label>
                <input type="range" id="in-freq" min="0.5" max="2.5" step="0.1" value="1.5">
            </div>
            <div class="control-group">
                <label>Amp: <span id="disp-amp">0.20</span> m</label>
                <input type="range" id="in-amp" min="0.05" max="0.30" step="0.01" value="0.20">
            </div>
            <div class="control-group">
                <label>Trim: <span id="disp-trim">1.0</span>°</label>
                <input type="range" id="in-trim" min="-5.0" max="10.0" step="0.5" value="1.0">
            </div>
            <div class="control-group">
                <label>Phase Shift: <span id="disp-phase">90</span>°</label>
                <input type="range" id="in-phase" min="0" max="180" step="5" value="90">
            </div>
            <div class="control-group">
                <label>Scale: <span id="disp-size">1.00</span></label>
                <input type="range" id="in-size" min="0.10" max="1.0" step="0.05" value="1.0">
            </div>
            
            <div class="legend-container">
                <div class="legend-title">Visibility</div>
                <div class="legend-items">
                    <label class="legend-item"><input type="checkbox" id="chk-lift" checked><div class="dot" style="background: blue;"></div> Lift</label>
                    <label class="legend-item"><input type="checkbox" id="chk-drag" checked><div class="dot" style="background: red;"></div> Drag</label>
                    <label class="legend-item"><input type="checkbox" id="chk-rider" checked><div class="dot" style="background: orange;"></div> Rider</label>
                    <label class="legend-item"><input type="checkbox" id="chk-net" checked><div class="dot" style="background: green;"></div> Net</label>
                    <label class="legend-item"><input type="checkbox" id="chk-thrust" checked><div class="dot" style="background: cyan; border:1px solid #999;"></div> Thrust</label>
                </div>
                <div style="font-size: 9px; color: #555; margin-top: 5px;">
                    <kbd>SPACE</kbd> Pause
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * PUMP FOIL SIMULATOR
 */

// --- CONFIGURATION ---
const CONFIG = {
    mass: 80.0,
    U: 5.0,             
    rho: 1000.0,
    S: 0.12,            
    Cd0: 0.02,
    k: 0.05,
    g: 9.81,
    visual_size_m: 1.0, 
    // Scales
    scale_L: 1.0, scale_D: 5.0, scale_T: 5.0, scale_R: 0.5, scale_N: 1.0,
    
    // Adjustable Parameters
    pitch_trim_deg: 1.0,
    phase_shift_deg: 90.0
};

// --- VISIBILITY STATE ---
const VISIBILITY = { lift: true, drag: true, rider: true, net: true, thrust: true };

// --- STATE ---
let state = {
    t: 0,
    dt: 0.02,
    paused: false,
    freq: 1.5,
    heave_amp: 0.20,
    pathX: [],
    pathZ: [],
    thrustHistory: [],
    avgThrustHistory: [],
    powerHistory: [],
    avgPowerHistory: []
};

// --- NACA PROFILE ---
function getNACA00xx(thickness, points) {
    const coords = [];
    for (let i = 0; i <= points; i++) {
        const beta = (i / points) * Math.PI;
        const x = (1 - Math.cos(beta)) / 2;
        const yt = 5 * thickness * (0.2969 * Math.sqrt(x) - 0.1260 * x - 0.3516 * Math.pow(x, 2) + 0.2843 * Math.pow(x, 3) - 0.1015 * Math.pow(x, 4));
        coords.push({x: x, y: yt});
    }
    return coords;
}
const foilShape = getNACA00xx(0.15, 40);

// --- DOM ELEMENTS ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const ctxThrust = document.getElementById('graphThrust').getContext('2d');
const ctxPower = document.getElementById('graphPower').getContext('2d');
const ctxAvgPower = document.getElementById('graphAvgPower').getContext('2d');

const ui = {
    time: document.getElementById('val-time'),
    speed: document.getElementById('val-speed'),
    watts: document.getElementById('val-watts'),
    avgWatts: document.getElementById('val-avg-watts'),
    avgThrust: document.getElementById('val-avg-thrust'),
    
    // Angle Displays
    pitch: document.getElementById('val-pitch'),
    aoa: document.getElementById('val-aoa'),
    
    dispFreq: document.getElementById('disp-freq'),
    dispAmp: document.getElementById('disp-amp'),
    dispSize: document.getElementById('disp-size'),
    dispSpeed: document.getElementById('disp-speed'),
    dispMass: document.getElementById('disp-mass'),
    dispArea: document.getElementById('disp-area'),
    dispTrim: document.getElementById('disp-trim'),
    dispPhase: document.getElementById('disp-phase')
};

// --- PHYSICS ENGINE ---
function calculatePhysics(t) {
    const omega = 2 * Math.PI * state.freq;
    
    // 1. Amplitudes & Setup
    const vz_max = state.heave_amp * omega;
    const gamma_max = Math.atan2(vz_max, CONFIG.U);
    const pitch_amp = gamma_max * 0.90; 
    
    const pitch_trim = CONFIG.pitch_trim_deg * (Math.PI / 180);
    const phase_rad = CONFIG.phase_shift_deg * (Math.PI / 180);

    // 2. Motion (Time-based)
    // Heave: Cosine (Starts at top)
    const z = state.heave_amp * Math.cos(omega * t);
    
    // Heave Derivatives
    const vz = -state.heave_amp * omega * Math.sin(omega * t);
    const az = -state.heave_amp * (omega ** 2) * Math.cos(omega * t);
    
    // Pitch: Uses Phase Shift relative to Heave
    const theta = pitch_trim + pitch_amp * Math.cos(omega * t + phase_rad);

    // 3. Angles & Velocities
    const x = CONFIG.U * t;
    const vx = CONFIG.U;
    
    const gamma = Math.atan2(vz, vx);
    const alpha = theta - gamma;
    const v_sq = vx*vx + vz*vz;
    
    // 4. Forces
    const Cl = 2 * Math.PI * alpha;
    const Cd = CONFIG.Cd0 + CONFIG.k * (Cl * Cl);
    
    const L_mag = 0.5 * CONFIG.rho * CONFIG.S * Cl * v_sq;
    const D_mag = 0.5 * CONFIG.rho * CONFIG.S * Cd * v_sq;
    
    const F_rider = CONFIG.mass * (CONFIG.g + az);
    
    // 5. Power
    const power = Math.max(0, F_rider * (-vz));

    // 6. Vector Components
    const Lx = -L_mag * Math.sin(gamma); const Lz = L_mag * Math.cos(gamma);
    const Dx = -D_mag * Math.cos(gamma); const Dz = -D_mag * Math.sin(gamma);
    const Rx = 0; const Rz = -F_rider;
    const Nx = Lx + Dx + Rx; const Nz = Lz + Dz + Rz; 
    
    return {
        x, z, alpha, gamma, theta, vz,
        Lx, Lz, Dx, Dz, Rx, Rz, Nx, Nz,
        thrust: Lx + Dx, 
        riderForce: F_rider,
        power: power
    };
}
 
// --- DRAWING ---
function drawArrow(ctx, startX, startY, u, v, color, scale, user_scale) {
    let len = Math.sqrt(u*u + v*v) * scale * user_scale;
    const MAX_LEN_PX = 150;
    let clamp = 1.0;
    if (len > MAX_LEN_PX) clamp = MAX_LEN_PX / len;
    const finalU = u * scale * user_scale * clamp;
    const finalV = v * scale * user_scale * clamp;
    const endX = startX + finalU;
    const endY = startY - finalV; 
    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
    ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke();
    const angle = Math.atan2(-finalV, finalU); const headLen = 10;
    ctx.beginPath(); ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
    ctx.fillStyle = color; ctx.fill();
}

function drawSimpleGraph(ctx, data, title, colorPositive, colorNegative) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const leftMargin = 44;
    const rightMargin = 8;
    const topMargin = 18;
    const bottomMargin = 12;

    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#444";
    ctx.fillText(title, leftMargin, 12);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    // Draw Y axis
    ctx.strokeStyle = '#ccc';
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(leftMargin, h - bottomMargin);
    ctx.stroke();

    if (data.length < 2) return;

    // Dynamic scaling: find max magnitude (for signed) or max value (for unsigned)
    let maxVal;
    if (colorNegative) {
        maxVal = Math.max(...data.map(v => Math.abs(v)));
    } else {
        maxVal = Math.max(...data);
    }
    if (!isFinite(maxVal) || maxVal <= 0) maxVal = 1;
    // Add a small padding so the line never touches the top
    maxVal *= 1.08;

    const midY = colorNegative ? (topMargin + plotH / 2) : (topMargin + plotH);
    const scaleY = colorNegative ? (plotH / 2) / maxVal : (plotH) / maxVal;

    // Draw horizontal zero (or baseline) line
    ctx.strokeStyle = '#eee';
    ctx.beginPath(); ctx.moveTo(leftMargin, midY); ctx.lineTo(w - rightMargin, midY); ctx.stroke();

    // Y labels: top, mid (zero if signed), bottom
    ctx.fillStyle = '#666';
    ctx.font = '11px sans-serif';
    if (colorNegative) {
        ctx.fillText(maxVal.toFixed(0), 6, topMargin + 10);
        ctx.fillText('0', 8, midY + 4);
        ctx.fillText((-maxVal).toFixed(0), 6, h - bottomMargin);
    } else {
        ctx.fillText(maxVal.toFixed(0), 6, topMargin + 10);
        ctx.fillText('0', 8, h - bottomMargin);
    }

    // Plot area and line
    const stepX = plotW / Math.max(1, data.length - 1);

    // Build points
    const pts = [];
    for (let i = 0; i < data.length; i++) {
        const val = data[i];
        const px = leftMargin + i * stepX;
        const py = midY - (val * scaleY);
        pts.push({px, py});
    }

    // Build polygon path that closes down to the baseline (midY)
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py);
    }
    ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
    ctx.lineTo(leftMargin, midY);
    ctx.closePath();

    // Fill only the area enclosed by the curve and the baseline.
    // For signed graphs (colorNegative provided) fill positive and negative sides separately
    if (colorNegative) {
        // Positive area (curve above baseline): intersect polygon with rect above midY
        ctx.save();
        // Clip to polygon
        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) { const p = pts[i]; if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py); }
        ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
        ctx.lineTo(leftMargin, midY);
        ctx.closePath();
        ctx.clip();
        // Intersect with rectangle above midY
        ctx.beginPath(); ctx.rect(leftMargin, topMargin, plotW, Math.max(0, midY - topMargin)); ctx.clip();
        ctx.fillStyle = colorPositive || 'rgba(0,0,0,0.15)';
        ctx.fillRect(leftMargin, topMargin, plotW, Math.max(0, midY - topMargin));
        ctx.restore();

        // Negative area (curve below baseline): intersect polygon with rect below midY
        ctx.save();
        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) { const p = pts[i]; if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py); }
        ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
        ctx.lineTo(leftMargin, midY);
        ctx.closePath();
        ctx.clip();
        ctx.beginPath(); ctx.rect(leftMargin, midY, plotW, Math.max(0, (h - bottomMargin) - midY)); ctx.clip();
        ctx.fillStyle = colorNegative || 'rgba(255,0,0,0.15)';
        ctx.fillRect(leftMargin, midY, plotW, Math.max(0, (h - bottomMargin) - midY));
        ctx.restore();
    } else {
        // Single-sided fill: clip to polygon and fill
        ctx.save();
        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) { const p = pts[i]; if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py); }
        ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
        ctx.lineTo(leftMargin, midY);
        ctx.closePath();
        ctx.clip();
        ctx.fillStyle = colorPositive || 'rgba(0,0,0,0.15)';
        ctx.fillRect(leftMargin, topMargin, plotW, plotH);
        ctx.restore();
    }

    // Stroke the line on top
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py);
    }
    ctx.stroke();
}

function drawSignGraph(ctx, data, title) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const leftMargin = 44;
    const rightMargin = 8;
    const topMargin = 6;
    const bottomMargin = 6;

    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#444";
    ctx.fillText(title, leftMargin, 12);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    // Draw Y axis (small)
    ctx.strokeStyle = '#ccc';
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(leftMargin, h - bottomMargin);
    ctx.stroke();

    if (!data || data.length === 0) return;

    const stepX = plotW / Math.max(1, data.length - 1);

    for (let i = 0; i < data.length; i++) {
        const val = data[i];
        const px = leftMargin + i * stepX;
        const wRect = Math.max(1, Math.ceil(stepX));
        ctx.fillStyle = (val >= 0) ? 'rgba(0,160,0,0.5)' : 'rgba(220,0,0,0.45)';
        ctx.fillRect(px, topMargin, wRect, plotH);
    }

    // Draw a thin separator line at mid (zero) for clarity
    ctx.strokeStyle = '#eee';
    ctx.beginPath(); ctx.moveTo(leftMargin, topMargin + plotH/2); ctx.lineTo(w - rightMargin, topMargin + plotH/2); ctx.stroke();
}

function drawSustainabilityGauge(ctx, avgThrust, maxThrustRef) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const margin = 8;
    const gaugeW = w - 2 * margin;
    const gaugeH = h - 2 * margin;
    const centerX = margin + gaugeW / 2;
    const centerY = margin + gaugeH / 2;

    // Clamp avgThrust to reasonable range
    const clampedThrust = Math.max(-maxThrustRef, Math.min(maxThrustRef, avgThrust));
    const normalized = clampedThrust / maxThrustRef; // -1 to +1

    // Background bar (light gray)
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(margin, margin, gaugeW, gaugeH);

    // Split into left (negative/red) and right (positive/green) halves
    const halfW = gaugeW / 2;

    // Left half: negative/deceleration (red)
    ctx.fillStyle = 'rgba(255, 100, 100, 0.2)';
    ctx.fillRect(margin, margin, halfW, gaugeH);

    // Right half: positive/acceleration (green)
    ctx.fillStyle = 'rgba(100, 200, 100, 0.2)';
    ctx.fillRect(margin + halfW, margin, halfW, gaugeH);

    // Fill indicator based on normalized thrust
    if (normalized < 0) {
        // Deceleration: fill from center left
        const fillW = Math.abs(normalized) * halfW;
        ctx.fillStyle = 'rgba(220, 50, 50, 0.6)';
        ctx.fillRect(centerX - fillW, margin, fillW, gaugeH);
    } else {
        // Acceleration: fill from center right
        const fillW = normalized * halfW;
        ctx.fillStyle = 'rgba(80, 180, 80, 0.6)';
        ctx.fillRect(centerX, margin, fillW, gaugeH);
    }

    // Center line (zero)
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centerX, margin);
    ctx.lineTo(centerX, margin + gaugeH);
    ctx.stroke();

    // Border
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(margin, margin, gaugeW, gaugeH);

    // Label text
    ctx.fillStyle = '#333';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Decel', margin + 4, margin + 12);
    ctx.textAlign = 'right';
    ctx.fillText('Accel', w - margin - 4, margin + 12);

    // Show numeric value
    ctx.textAlign = 'center';
    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = (normalized >= 0) ? '#008000' : '#c00000';
    ctx.fillText(avgThrust.toFixed(0) + ' N', centerX, margin + gaugeH - 2);
}


// --- MAIN LOOP ---
function render() {
    const phys = calculatePhysics(state.t);
    
    // History
    state.thrustHistory.push(phys.thrust);
    if (state.thrustHistory.length > 150) state.thrustHistory.shift();
    state.powerHistory.push(phys.power);
    if (state.powerHistory.length > 150) state.powerHistory.shift();
    
    const avgP = state.powerHistory.reduce((a, b) => a + b, 0) / state.powerHistory.length;
    
    // UI
    ui.time.textContent = state.t.toFixed(2);
    ui.speed.textContent = (CONFIG.U * 3.6).toFixed(1);
    
    // Update New Angle Displays
    ui.pitch.textContent = (phys.theta * 180 / Math.PI).toFixed(1);
    ui.aoa.textContent = (phys.alpha * 180 / Math.PI).toFixed(1);

    ui.watts.textContent = phys.power.toFixed(0);
    ui.avgWatts.textContent = avgP.toFixed(0);
    
    state.pathX.push(phys.x);
    state.pathZ.push(phys.z);
    if (state.pathX.length > 150) { state.pathX.shift(); state.pathZ.shift(); }
    
    // Canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const PPU = 100;
    const camX = phys.x * PPU;
    const camOffset = canvas.width / 3;
    
    ctx.save();
    ctx.translate(-camX + camOffset, canvas.height / 2);
    
    // Environment
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 1;
    ctx.beginPath();
    const startGrid = Math.floor((phys.x - 2)); const endGrid = Math.floor((phys.x + 8));
    for (let i = startGrid; i <= endGrid; i++) { ctx.moveTo(i * PPU, -500); ctx.lineTo(i * PPU, 500); }
    ctx.moveTo(-10000, 0); ctx.lineTo(10000, 0); ctx.stroke();
    
    // Trail
    ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
    for(let i=0; i<state.pathX.length; i++){
        const px = state.pathX[i] * PPU; const pz = -state.pathZ[i] * PPU;
        if (i===0) ctx.moveTo(px, pz); else ctx.lineTo(px, pz);
    }
    ctx.stroke();
    
    const foilCX = phys.x * PPU; const foilCY = -phys.z * PPU;
    
    // Foil
    ctx.save(); ctx.translate(foilCX, foilCY); ctx.rotate(-phys.theta); 
    const chordPx = CONFIG.visual_size_m * PPU;
    const toLocalX = (nx) => (0.25 - nx) * chordPx; 
    ctx.beginPath(); ctx.fillStyle = 'black';
    ctx.moveTo(toLocalX(foilShape[0].x), -foilShape[0].y * chordPx);
    for (let i = 1; i < foilShape.length; i++) ctx.lineTo(toLocalX(foilShape[i].x), -foilShape[i].y * chordPx);
    for (let i = foilShape.length - 1; i >= 0; i--) ctx.lineTo(toLocalX(foilShape[i].x), foilShape[i].y * chordPx);
    ctx.fill(); ctx.restore();

    // Vectors
    const vecScale = 0.2; 
    if (VISIBILITY.lift) drawArrow(ctx, foilCX, foilCY, phys.Lx, phys.Lz, 'blue', vecScale, CONFIG.scale_L);
    if (VISIBILITY.drag) drawArrow(ctx, foilCX, foilCY, phys.Dx, phys.Dz, 'red', vecScale, CONFIG.scale_D);
    if (VISIBILITY.rider) drawArrow(ctx, foilCX, foilCY, phys.Rx, phys.Rz, 'orange', vecScale, CONFIG.scale_R);
    if (VISIBILITY.net) drawArrow(ctx, foilCX, foilCY, phys.Nx, phys.Nz, 'green', vecScale, CONFIG.scale_N);
    if (VISIBILITY.thrust) drawArrow(ctx, foilCX, foilCY, phys.thrust, 0, 'cyan', vecScale, CONFIG.scale_T);

    ctx.restore();
    
    // Graphs
    drawSimpleGraph(ctxThrust, state.thrustHistory, "NET THRUST (N)", "rgba(0,128,0,0.35)", "rgba(255,0,0,0.28)");
    drawSimpleGraph(ctxPower, state.powerHistory, "RIDER POWER (Watts)", "rgba(255,165,0,0.4)", null);

    // Compute and track average power over at least 4 pump cycles
    // Cycle period in seconds = 1/freq
    const cyclePeriod = 1.0 / state.freq;
    // Samples per cycle = cyclePeriod / dt
    const samplesPerCycle = cyclePeriod / state.dt;
    // Window size = 4 cycles worth of samples
    const windowSize = Math.ceil(samplesPerCycle * 4);
    // Get the last windowSize samples (or all if fewer available)
    const avgPowerWindow = state.powerHistory.slice(Math.max(0, state.powerHistory.length - windowSize));
    const avgPower = (avgPowerWindow.length > 0) ? (avgPowerWindow.reduce((a,b)=>a+b,0)/avgPowerWindow.length) : 0;
    state.avgPowerHistory.push(avgPower);
    if (state.avgPowerHistory.length > 150) state.avgPowerHistory.shift();
    drawSimpleGraph(ctxAvgPower, state.avgPowerHistory, "AVG POWER (Watts)", "rgba(255,140,0,0.5)", null);

    // Average thrust sign timeline
    const avgThrust = (state.thrustHistory.length > 0) ? (state.thrustHistory.reduce((a,b)=>a+b,0)/state.thrustHistory.length) : 0;
    state.avgThrustHistory.push(avgThrust);
    if (state.avgThrustHistory.length > 150) state.avgThrustHistory.shift();

    // Update avg thrust status bar
    ui.avgThrust.textContent = avgThrust.toFixed(0);
    const statusEl = document.getElementById('avgThrustStatus');
    if (avgThrust >= 0) {
        statusEl.style.backgroundColor = '#c8e6c9';
        statusEl.style.color = '#1b5e20';
        statusEl.textContent = 'Avg Thrust: Accelerating — ' + avgThrust.toFixed(0) + ' N';
    } else {
        statusEl.style.backgroundColor = '#ffcdd2';
        statusEl.style.color = '#b71c1c';
        statusEl.textContent = 'Avg Thrust: Decelerating — ' + avgThrust.toFixed(0) + ' N';
    }
}

// --- LISTENERS ---
document.getElementById('in-freq').addEventListener('input', (e) => { state.freq = parseFloat(e.target.value); ui.dispFreq.textContent = state.freq.toFixed(1); });
document.getElementById('in-amp').addEventListener('input', (e) => { state.heave_amp = parseFloat(e.target.value); ui.dispAmp.textContent = state.heave_amp.toFixed(2); });
document.getElementById('in-size').addEventListener('input', (e) => { CONFIG.visual_size_m = parseFloat(e.target.value); ui.dispSize.textContent = CONFIG.visual_size_m.toFixed(2); });
document.getElementById('in-speed').addEventListener('input', (e) => { const kph = parseFloat(e.target.value); CONFIG.U = kph / 3.6; ui.dispSpeed.textContent = kph.toFixed(1); });
document.getElementById('in-mass').addEventListener('input', (e) => { CONFIG.mass = parseFloat(e.target.value); ui.dispMass.textContent = CONFIG.mass.toFixed(0); });
document.getElementById('in-area').addEventListener('input', (e) => { const cm2 = parseFloat(e.target.value); CONFIG.S = cm2 / 10000; ui.dispArea.textContent = cm2.toFixed(0); });
document.getElementById('in-trim').addEventListener('input', (e) => { CONFIG.pitch_trim_deg = parseFloat(e.target.value); ui.dispTrim.textContent = CONFIG.pitch_trim_deg.toFixed(1); });
document.getElementById('in-phase').addEventListener('input', (e) => { CONFIG.phase_shift_deg = parseFloat(e.target.value); ui.dispPhase.textContent = CONFIG.phase_shift_deg.toFixed(0); });

document.getElementById('chk-lift').addEventListener('change', (e) => VISIBILITY.lift = e.target.checked);
document.getElementById('chk-drag').addEventListener('change', (e) => VISIBILITY.drag = e.target.checked);
document.getElementById('chk-rider').addEventListener('change', (e) => VISIBILITY.rider = e.target.checked);
document.getElementById('chk-net').addEventListener('change', (e) => VISIBILITY.net = e.target.checked);
document.getElementById('chk-thrust').addEventListener('change', (e) => VISIBILITY.thrust = e.target.checked);

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') state.paused = !state.paused;
    if (state.paused) {
        if (e.code === 'ArrowRight') state.t += state.dt;
        if (e.code === 'ArrowLeft') state.t -= state.dt;
        render();
    }
});

function loop() {
    if (!state.paused) {
        state.t += state.dt;
        if(state.t > 1000) state.t = 0;
        render();
    }
    requestAnimationFrame(loop);
}

render();
loop();

</script>
</body>
</html>