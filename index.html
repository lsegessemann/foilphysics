<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pump Foil Simulator (Angle Telemetry)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
            background-color: #f4f4f5;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            overflow: auto;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            max-width: 900px;
        }

        .canvas-wrapper {
            position: relative;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.05);
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
            width: 100%;
            height: auto;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            pointer-events: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            min-width: 200px;
            z-index: 10;
        }

        #controls {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 240px;
            box-sizing: border-box;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 110px;
        }

        label {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
        }

        input[type=range] {
            height: 4px;
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 6px 0;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* LEGEND STYLES */
        .legend-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .legend-title {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .legend-items { display: flex; flex-direction: column; gap: 6px; font-size: 11px; }
        .legend-item { display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        input[type=checkbox] { cursor: pointer; }
        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-size: 9px;
            font-weight: 700;
        }

        #dashboard-row {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
        }
        #graphs-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }

        /* Make graphs fill the available height to align with controls */
        #graphs-column .canvas-wrapper:not(#avgThrustStatus):not(#avgLiftStatus) {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #graphs-column .canvas-wrapper:not(#avgThrustStatus):not(#avgLiftStatus) canvas {
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            #dashboard-row {
                flex-direction: column;
            }
            #controls {
                width: 100%;
                display: grid;
                grid-template-columns: 1fr 1fr;
            }
            #ui-overlay {
                font-size: 11px;
                padding: 10px;
                min-width: 140px;
                right: 10px;
                top: 10px;
            }
        }

        /* Custom Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #888;
        }
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px 10px;
            position: absolute;
            z-index: 100;
            top: 50%;
            right: 105%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.1s;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.4;
            font-weight: normal;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none;
        }
        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 100%;
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent transparent #333;
        }
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Documentation Dropdown */
        details {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0,0,0,0.05);
            overflow: hidden;
            width: 100%;
            margin-top: 15px;
            box-sizing: border-box;
        }
        summary {
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            background-color: #fff;
            font-size: 14px;
            color: #333;
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        summary::-webkit-details-marker {
            display: none;
        }
        summary::after {
            content: '+';
            font-size: 18px;
            font-weight: bold;
            color: #666;
        }
        details[open] summary::after {
            content: '-';
        }
        details[open] summary {
            border-bottom: 1px solid #eee;
        }
        .readme-content {
            padding: 20px;
            font-size: 13px;
            line-height: 1.6;
            color: #444;
        }
        .readme-content h1 { font-size: 18px; margin-top: 0; margin-bottom: 10px; color: #222; }
        .readme-content h2 { font-size: 16px; margin-top: 15px; margin-bottom: 10px; color: #333; }
        .readme-content p { margin-bottom: 10px; }
        .readme-content ul { margin-bottom: 10px; padding-left: 20px; }
        .readme-content li { margin-bottom: 4px; }
        .readme-content a { color: #3b82f6; text-decoration: none; }
        .readme-content a:hover { text-decoration: underline; }
    </style>
</head>
<body>

    <div id="main-container">
        <div class="canvas-wrapper">
            <canvas id="simCanvas" width="900" height="380"></canvas>
            <div id="ui-overlay">
                <strong>Live Telemetry</strong><br>
                Time: <span id="val-time">0.00</span> s<br>
                Speed: <span id="val-speed">18.0</span> km/h<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Pitch (vs Horizon): <span id="val-pitch">0.0</span>°<br>
                <span class="tooltip">AoA (vs Water flow)
                    <span class="tooltip-text">
                        The angle of the wing relative to the oncoming water flow (not the horizon).<br>
                        • Positive AoA generates Lift.<br>
                        • Too high (>12°) causes Drag and Stalling.<br>
                        • In a pump, plunging down increases your AoA, while rising up decreases it.
                    </span>
                </span>: <span id="val-aoa">0.0</span>°<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Inst. Power: <span id="val-watts">0</span> W<br>
                Avg. Power: <span id="val-arith-avg-watts">0</span> W<br>
                Norm. Power: <span id="val-avg-watts">0</span> W
            </div>
        </div>

        <div id="dashboard-row">
            <div id="graphs-column">
                <div class="canvas-wrapper">
                    <canvas id="graphLift" width="1300" height="120"></canvas>
                </div>
                <div class="canvas-wrapper" id="avgLiftStatus" style="padding: 10px; text-align: center; font-size: 14px; font-weight: bold; background-color: #e8f5e9;">
                    Avg Lift: Balanced : <span id="val-avg-lift">0</span> N
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphThrust" width="1300" height="120"></canvas>
                </div>
                <div class="canvas-wrapper" id="avgThrustStatus" style="padding: 10px; text-align: center; font-size: 14px; font-weight: bold; background-color: #e8f5e9;">
                    Avg Thrust: Accelerating : <span id="val-avg-thrust">0</span> N
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphPower" width="1300" height="120"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphAvgPower" width="1300" height="120"></canvas>
                </div>
            </div>
            
            <div id="controls">
            <div class="control-group" title="Pumping cadence in cycles per second (Hz).">
                <label>Frequency: <span id="disp-freq">1.65</span> Hz</label>
                <input type="range" id="in-freq" min="0.01" max="2.0" step="0.01" value="1.65">
            </div>
            <div class="control-group" title="Vertical range of motion for the foil path.">
                <label>Amplitude: <span id="disp-amp">0.13</span> m</label>
                <input type="range" id="in-amp" min="0.00" max="0.30" step="0.01" value="0.13">
            </div>
            <div class="control-group" title="Forward velocity of the rider.">
                <label>Speed: <span id="disp-speed">20.0</span> km/h</label>
                <input type="range" id="in-speed" min="10.0" max="30.0" step="1.0" value="20.0">
            </div>
            <div class="control-group" title="Base pitch angle of the front wing relative to the fuselage.">
                <label>Frontwing Pitch Trim: <span id="disp-trim">3.3</span>°</label>
                <input type="range" id="in-trim" min="-2.0" max="6.0" step="0.1" value="3.3">
            </div>
            <div class="control-group" title="Total weight of rider plus gear.">
                <label>Mass: <span id="disp-mass">70</span> kg</label>
                <input type="range" id="in-mass" min="40" max="120" step="1" value="70">
            </div>
            <div class="control-group" title="Percentage of body mass that moves with the board up and down.">
                <label>Swing Weight: <span id="disp-swing">40</span>%</label>
                <input type="range" id="in-swing" min="0.1" max="0.8" step="0.05" value="0.4">
            </div>
            <div class="control-group" title="Surface area of the front wing. Larger wings lift more but drag more.">
                <label>Wing Area: <span id="disp-area">1350</span> cm²</label>
                <input type="range" id="in-area" min="600" max="2000" step="50" value="1350">
            </div>
            <div class="control-group" title="Ratio of span to chord. High AR is more efficient (glides better).">
                <label>Aspect Ratio: <span id="disp-ar">13.9</span></label>
                <input type="range" id="in-ar" min="5.0" max="20.0" step="0.1" value="13.9">
            </div>
            <div class="control-group" title="Parasitic drag. Lower is more hydrodynamic (thinner mast/wing).">
                <label>Drag Coeff (Cd0): <span id="disp-cd0">0.015</span></label>
                <input type="range" id="in-cd0" min="0.010" max="0.035" step="0.001" value="0.015">
            </div>
            <div class="control-group" title="Timing difference between the heave (up/down) and pitch motions.">
                <label>Phase Shift: <span id="disp-phase">90</span>°</label>
                <input type="range" id="in-phase" min="85" max="95" step="1" value="90">
            </div>
            <div class="control-group" title="Zoom level for the foil visualization.">
                <label>Visualization Scale: <span id="disp-size">0.40</span></label>
                <input type="range" id="in-size" min="0.10" max="1.0" step="0.05" value="0.4">
            </div>
            <div class="control-group" style="flex-direction: row; align-items: center; gap: 6px; margin-top: 4px;">
                <input type="checkbox" id="chk-slowmo" style="height: auto;">
                <label for="chk-slowmo" style="margin: 0; cursor: pointer;">Slow Motion (1/5x)</label>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 5px;">
                <button id="btn-reset" style="flex: 1; padding: 8px; cursor: pointer; font-size: 11px; font-weight: bold; background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 6px; color: #475569; transition: background 0.2s;">RESET</button>
                <button id="btn-replay" style="flex: 1; padding: 8px; cursor: pointer; font-size: 11px; font-weight: bold; background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 6px; color: #475569; transition: background 0.2s;">REPLAY</button>
            </div>

            <div class="legend-container">
                <div class="legend-title">Visibility</div>
                <div class="legend-items">
                    <label class="legend-item"><input type="checkbox" id="chk-lift" checked><div class="dot" style="background: blue;"></div> Lift Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-drag" checked><div class="dot" style="background: red;"></div> Drag Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-rider" checked><div class="dot" style="background: orange;"></div> Rider Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-net"><div class="dot" style="background: green;"></div> Net Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-thrust" checked><div class="dot" style="background: cyan; border:1px solid #999;"></div> Thrust Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-assembly" checked><div class="dot" style="background: #666;"></div> Foilboard and Rider </label>
                </div>
                <div style="font-size: 9px; color: #555; margin-top: 5px;">
                    <kbd>SPACE</kbd> Pause
                </div>
            </div> <!-- End legend-container -->
        </div> <!-- End controls -->
        </div> <!-- End dashboard-row -->

        <details id="readme-dropdown">
            <summary>Documentation & About</summary>
            <div class="readme-content">
                <h2>Physics Model</h2>
                <p>The simulation uses a custom quasi-steady solver that iterates through time steps (<i>dt</i>) to calculate forces and rider power.</p>

                <h3>1. Kinematics (Motion)</h3>
                <p>The rider's vertical motion (<strong>Heave</strong>) and the board's angle (<strong>Pitch</strong>) are driven by sinusoidal functions, linked by a configurable <strong>Phase Shift</strong>.</p>

                <ul>
                    <li><strong>Frequency:</strong> <i>&omega; = 2&pi;f</i></li>
                    <li><strong>Vertical Position (<i>z</i>):</strong> <i>z(t) = A cos(&omega;t)</i></li>
                    <li><strong>Vertical Velocity (<i>v<sub>z</sub></i>):</strong> <i>v<sub>z</sub>(t) = -A &omega; sin(&omega;t)</i></li>
                    <li><strong>Vertical Acceleration (<i>a<sub>z</sub></i>):</strong> <i>a<sub>z</sub>(t) = -A &omega;<sup>2</sup> cos(&omega;t)</i></li>
                    <li><strong>Pitch Angle (<i>&theta;</i>):</strong> <i>&theta;(t) = &theta;<sub>trim</sub> + &theta;<sub>amp</sub> cos(&omega;t + &phi;)</i><br>
                    <em>(Where &phi; is the Phase Shift)</em></li>
                </ul>

                <h3>2. Aerodynamics (Fluid Forces)</h3>
                <p>Lift and Drag are calculated using <strong>Thin Airfoil Theory</strong>, corrected for a finite Aspect Ratio (<i>AR</i>).</p>

                <ul>
                    <li><strong>Flight Path Angle (<i>&gamma;</i>):</strong> <i>&gamma; = arctan(v<sub>z</sub> / U)</i></li>
                    <li><strong>Effective Angle of Attack (<i>&alpha;</i>):</strong> <i>&alpha; = &theta; - &gamma;</i></li>
                    <li><strong>Lift Coefficient (<i>C<sub>L</sub></i>):</strong><br>
                    <i>C<sub>L</sub> = (2 &pi; &alpha;) / (1 + 2/AR)</i></li>
                    <li><strong>Drag Coefficient (<i>C<sub>D</sub></i>):</strong><br>
                    <i>C<sub>D</sub> = C<sub>D0</sub> + k C<sub>L</sub><sup>2</sup></i> &emsp; where &emsp; <i>k &approx; 1 / (&pi; AR)</i></li>
                    <li><strong>Hydrodynamic Force (Vertical Component):</strong><br>
                    <i>F<sub>hydro_z</sub> = L cos(&gamma;) - D sin(&gamma;)</i></li>
                </ul>

                <h3>3. Dynamics (Two-Mass Model)</h3>
                <p>To simulate high-frequency pumping accurately, the system is split into a <strong>Fixed Mass</strong> (Torso) and a <strong>Moving Mass</strong> (Legs + Board). This prevents the "zero power" error seen in single-point mass models when acceleration exceeds gravity.</p>

                <ul>
                    <li><strong>Moving Mass (<i>m<sub>moving</sub></i>):</strong><br>
                    <i>m<sub>moving</sub> = m<sub>board</sub> + (m<sub>rider</sub> &times; SwingRatio)</i><br>
                    <em>(Default SwingRatio is 0.4, representing the active mass of the legs)</em></li>
                    <li><strong>Inertial Requirement:</strong><br>
                    The force required to accelerate the legs and board:<br>
                    <i>F<sub>inertia</sub> = m<sub>moving</sub> (g + a<sub>z</sub>)</i></li>
                    <li><strong>Rider Force (<i>F<sub>rider</sub></i>):</strong><br>
                    The rider must push down to bridge the gap between the Water Force and the Inertial Force.<br>
                    <i>F<sub>req</sub> = F<sub>hydro_z</sub> - F<sub>inertia</sub></i><br>
                    <i>F<sub>rider</sub> = max(0, F<sub>req</sub>)</i><br>
                    <em>(Clamped to 0 to simulate unstrapped riding—the rider cannot pull the board up).</em></li>
                </ul>

                <h3>4. Power Calculation</h3>
                <p>Power is calculated as the product of the Rider's Force and the Leg Extension Velocity.</p>

                <ul>
                    <li><strong>Extension Velocity:</strong> <i>v<sub>ext</sub> = -v<sub>z</sub></i> <em>(Positive when pushing down)</em></li>
                    <li><strong>Instantaneous Power:</strong><br>
                    <i>P<sub>inst</sub> = F<sub>rider</sub> &times; v<sub>ext</sub></i><br>
                    <i>P = max(0, P<sub>inst</sub>)</i><br>
                    <em>(Negative power is clamped to 0, assuming the rider does not regenerate energy from the board pushing back).</em></li>
                </ul>
            </div>
        </details>
    </div>

<script>
/**
 * PUMP FOIL SIMULATOR
 */

// --- CONFIGURATION ---
const CONFIG = {
    mass: 70.0,          // Total mass (Rider + Board) in kg
    U: 20.0 / 3.6,       // Forward speed in m/s (converted from km/h)
    rho: 1000.0,         // Water density in kg/m³
    S: 0.135,            // Wing area in m² (e.g., 1350 cm² = 0.135 m²)
    Cd0: 0.015,          // Parasitic Drag Coefficient (0.015=Pro, 0.02=Std, 0.03=Draggy)
    k: 0.05,             // Induced Drag Factor (recalculated based on AR)
    g: 9.81,             // Gravity (m/s²)
    visual_size_m: 0.4,  // Visual scale for foil chord length
    // Scales
    scale_L: 0.5, scale_D: 5.0, scale_T: 1.0, scale_R: 0.5, scale_N: 0.5,
    AR: 13.9,            // Aspect Ratio (Span² / Area)
    
    // Adjustable Parameters
    pitch_trim_deg: 3.3,    // Base pitch angle in degrees
    phase_shift_deg: 90.0,  // Phase difference between Heave and Pitch
    swing_weight_ratio: 0.4 // Percentage of body mass considered moving (legs)
};

// --- VISIBILITY STATE ---
const VISIBILITY = { lift: true, drag: true, rider: true, net: false, thrust: true, assembly: true };

// --- STATE ---
let state = {
    t: 0,
    dt: 0.01,
    historyTimer: 0,
    paused: false,
    slowMotion: false,
    freq: 1.65,
    heave_amp: 0.13,
    pathX: [],
    pathZ: [],
    liftHistory: [],
    thrustHistory: [],
    avgThrustHistory: [],
    avgLiftHistory: [],
    powerHistory: [],
    avgPowerHistory: [],
    arithmeticAvgPowerHistory: []
};

// --- NACA PROFILE ---
function getNACA00xx(thickness, points) {
    const coords = [];
    for (let i = 0; i <= points; i++) {
        const beta = (i / points) * Math.PI;
        const x = (1 - Math.cos(beta)) / 2;
        const yt = 5 * thickness * (0.2969 * Math.sqrt(x) - 0.1260 * x - 0.3516 * Math.pow(x, 2) + 0.2843 * Math.pow(x, 3) - 0.1015 * Math.pow(x, 4));
        coords.push({x: x, y: yt});
    }
    return coords;
}
const foilShape = getNACA00xx(0.15, 40);

// --- DOM ELEMENTS ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const ctxLift = document.getElementById('graphLift').getContext('2d');
const ctxThrust = document.getElementById('graphThrust').getContext('2d');
const ctxPower = document.getElementById('graphPower').getContext('2d');
const ctxAvgPower = document.getElementById('graphAvgPower').getContext('2d');

const ui = {
    time: document.getElementById('val-time'),
    speed: document.getElementById('val-speed'),
    watts: document.getElementById('val-watts'),
    arithAvgWatts: document.getElementById('val-arith-avg-watts'),
    avgWatts: document.getElementById('val-avg-watts'),
    avgThrust: document.getElementById('val-avg-thrust'),
    
    // Angle Displays
    pitch: document.getElementById('val-pitch'),
    aoa: document.getElementById('val-aoa'),
    
    dispFreq: document.getElementById('disp-freq'),
    dispAmp: document.getElementById('disp-amp'),
    dispSize: document.getElementById('disp-size'),
    dispSpeed: document.getElementById('disp-speed'),
    dispMass: document.getElementById('disp-mass'),
    dispArea: document.getElementById('disp-area'),
    dispAr: document.getElementById('disp-ar'),
    dispCd0: document.getElementById('disp-cd0'),
    dispTrim: document.getElementById('disp-trim'),
    dispPhase: document.getElementById('disp-phase'),
    dispSwing: document.getElementById('disp-swing')
};

// --- PHYSICS ENGINE ---
function calculatePhysics(t) {
    const omega = 2 * Math.PI * state.freq;
    
    // --- 1. CONFIGURATION FOR 2-MASS MODEL (LEGS + BOARD) ---
    // Standard anthropometry: Both legs are approx 33-35% of total body mass.
    // The "Moving Mass" is the Board + The Legs.
    // The "Fixed Mass" is the Torso/Head/Arms.
    
    const m_board_gear = 8.0; // Foil + Board + Wet wetusit (kg)
    const m_legs = CONFIG.mass * CONFIG.swing_weight_ratio;
    
    const m_moving = m_board_gear + m_legs; 
    // m_moving is the mass we must accelerate violently (~30-35kg total)
    
    // --- 2. KINEMATICS (Moving Mass Motion) ---
    const vz_max = state.heave_amp * omega;
    const gamma_max = Math.atan2(vz_max, CONFIG.U);
    const pitch_amp = gamma_max * 0.90; 
    
    const pitch_trim = CONFIG.pitch_trim_deg * (Math.PI / 180);
    const phase_rad = CONFIG.phase_shift_deg * (Math.PI / 180);

    // Position (z), Velocity (vz), Acceleration (az) of the FEET/BOARD
    const z = state.heave_amp * Math.cos(omega * t);
    const vz = -state.heave_amp * omega * Math.sin(omega * t);
    const az = -state.heave_amp * (omega ** 2) * Math.cos(omega * t);
    
    const theta = pitch_trim + pitch_amp * Math.cos(omega * t + phase_rad);

    // --- 3. AERODYNAMICS ---
    const x = CONFIG.U * t;
    const vx = CONFIG.U;
    
    const gamma = Math.atan2(vz, vx);
    const alpha = theta - gamma;
    const v_sq = vx*vx + vz*vz;
    
    // Lift & Drag
    let Cl = (2 * Math.PI * alpha) / (1 + 2 / CONFIG.AR);
    const k = 1 / (Math.PI * CONFIG.AR);
    const Cd = CONFIG.Cd0 + k * (Cl * Cl);
    
    const L_mag = 0.5 * CONFIG.rho * CONFIG.S * Cl * v_sq;
    const D_mag = 0.5 * CONFIG.rho * CONFIG.S * Cd * v_sq;
    
    const Lx = -L_mag * Math.sin(gamma); const Lz = L_mag * Math.cos(gamma);
    const Dx = -D_mag * Math.cos(gamma); const Dz = -D_mag * Math.sin(gamma);
    
    // --- 4. DYNAMICS (The "Leg Stomp") ---
    
    // F_hydro_z: The water pushing UP on the foil.
    const F_hydro_z = Lz + Dz; 

    // F_inertia_moving: Force needed to accelerate Board + Legs
    // If az is negative (accelerating down), this reduces the need for support.
    const F_inertia_moving = m_moving * (CONFIG.g + az);

    // F_legs_push: The force the TORSO exerts on the LEGS to drive them.
    // Free Body Diagram on Moving Mass (Legs + Board):
    // Upward Forces: Hydro_Lift
    // Downward Forces: Gravity, Push_from_Torso
    // Net Acceleration: az
    // Equation: Hydro - Gravity - Push = m * az
    // Solve for Push: Push = Hydro - m(g + az)
    let F_legs_push = F_hydro_z - F_inertia_moving;
    
    // CLAMP:
    // If F_legs_push is negative, it means the board is pulling the legs down 
    // (or lifting them up faster than they want to go). 
    // In unstrapped riding, we can't pull up. We just unweight (0 force).
    // However, with heavy legs, you might actively push them down (positive force)
    // even if the board is falling, just to keep up with the fall rate!
    const F_rider_action = Math.max(0, F_legs_push);

    // --- 5. POWER ---
    // Power = Force * Velocity of Extension
    // We assume Torso is fixed (V=0). Legs move at vz.
    // Extension Velocity = -vz (positive when board moves down)
    let rawPower = F_legs_push * (-vz);
    
    // Filter: Only calculate power during the down-stroke (vz < 0).
    // During up-stroke (vz > 0), we either brake (negative) or phantom-pull (positive), neither of which we want.
    if (vz > 0) rawPower = 0;
    
    // Only count positive power (concentric muscle phase)
    let power = Math.max(0, rawPower);

    // --- 6. OUTPUTS ---
    const Rx = 0; 
    const Rz = -F_rider_action; 
    
    const Nx = CONFIG.mass * 0; 
    const Nz = CONFIG.mass * az; // Visualizing total acceleration for reference
    
    return {
        x, z, alpha, gamma, theta, vz, az,
        Lx, Lz, Dx, Dz, Rx, Rz, Nx, Nz,
        thrust: Lx + Dx, 
        riderForce: F_rider_action,
        power: power,
        rawPower: rawPower
    };
}
 
// --- DRAWING ---
function drawArrow(ctx, startX, startY, u, v, color, scale, user_scale) {
    let len = Math.sqrt(u*u + v*v) * scale * user_scale;
    const MAX_LEN_PX = 150;
    let clamp = 1.0;
    if (len > MAX_LEN_PX) clamp = MAX_LEN_PX / len;
    const finalU = u * scale * user_scale * clamp;
    const finalV = v * scale * user_scale * clamp;
    const endX = startX + finalU;
    const endY = startY - finalV; 
    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
    ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke();
    const angle = Math.atan2(-finalV, finalU); const headLen = 10;
    ctx.beginPath(); ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
    ctx.fillStyle = color; ctx.fill();
}

function drawSimpleGraph(ctx, data, title, colorPositive, colorNegative, data2, color2) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    
    // Scale factor for High DPI (assuming base height of 60px)
    const scale = h / 60;

    ctx.clearRect(0, 0, w, h);

    const fontStack = "Verdana, Arial, sans-serif";
    
    const leftMargin = 50 * scale;
    const rightMargin = 10 * scale;
    const topMargin = 20 * scale;
    const bottomMargin = 15 * scale;

    // Title
    ctx.font = "bold " + (7 * scale) + "px " + fontStack;
    ctx.fillStyle = "#555";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(title.toUpperCase(), leftMargin, 5 * scale);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    if (data.length < 2) return;

    // Scaling
    let maxVal;
    let max1 = 0;
    if (data.length > 0) {
        if (colorNegative) {
            max1 = Math.max(...data.map(v => Math.abs(v)));
        } else {
            max1 = Math.max(...data);
        }
    }
    let max2 = 0;
    if (data2 && data2.length > 0) {
        max2 = Math.max(...data2);
    }
    maxVal = Math.max(max1, max2);

    if (!isFinite(maxVal) || maxVal <= 1) maxVal = 10;

    const midY = colorNegative ? (topMargin + plotH / 2) : (topMargin + plotH);
    const scaleY = colorNegative ? (plotH / 2) / maxVal : (plotH) / maxVal;

    // Grid & Axis
    ctx.strokeStyle = '#e4e4e7'; // Zinc-200
    ctx.lineWidth = 1 * scale;
    
    // Zero line
    ctx.beginPath(); 
    ctx.moveTo(leftMargin, midY); 
    ctx.lineTo(w - rightMargin, midY); 
    ctx.stroke();

    // Max line
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(w - rightMargin, topMargin);
    ctx.stroke();

    if (colorNegative) {
        ctx.beginPath();
        ctx.moveTo(leftMargin, h - bottomMargin);
        ctx.lineTo(w - rightMargin, h - bottomMargin);
        ctx.stroke();
    }

    // Labels
    ctx.fillStyle = "#666";
    ctx.font = (6.5 * scale) + "px " + fontStack;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";

    if (colorNegative) {
        ctx.fillText(maxVal.toFixed(0), leftMargin - 6 * scale, topMargin);
        ctx.fillText('0', leftMargin - 6 * scale, midY);
        ctx.fillText((-maxVal).toFixed(0), leftMargin - 6 * scale, h - bottomMargin);
    } else {
        ctx.fillText(maxVal.toFixed(0), leftMargin - 6 * scale, topMargin);
        ctx.fillText('0', leftMargin - 6 * scale, h - bottomMargin);
    }

    // Plot
    const stepX = plotW / Math.max(1, data.length - 1);
    const pts = [];
    for (let i = 0; i < data.length; i++) {
        pts.push({
            x: leftMargin + i * stepX,
            y: midY - (data[i] * scaleY)
        });
    }

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    if (colorNegative) {
        // 1. Positive Area
        ctx.save();
        ctx.beginPath();
        ctx.rect(leftMargin, topMargin - 2 * scale, plotW, midY - topMargin + 2 * scale);
        ctx.clip();
        
        ctx.beginPath();
        ctx.moveTo(pts[0].x, midY);
        for (let p of pts) ctx.lineTo(p.x, p.y);
        ctx.lineTo(pts[pts.length-1].x, midY);
        ctx.closePath();
        
        let grad = ctx.createLinearGradient(0, topMargin, 0, midY);
        grad.addColorStop(0, colorPositive); 
        grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = grad;
        ctx.fill();
        
        ctx.strokeStyle = colorPositive.replace(/[\d.]+\)$/, '1)'); 
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();
        ctx.restore();

        // 2. Negative Area
        ctx.save();
        ctx.beginPath();
        ctx.rect(leftMargin, midY, plotW, h - bottomMargin - midY + 2 * scale);
        ctx.clip();
        
        ctx.beginPath();
        ctx.moveTo(pts[0].x, midY);
        for (let p of pts) ctx.lineTo(p.x, p.y);
        ctx.lineTo(pts[pts.length-1].x, midY);
        ctx.closePath();
        
        grad = ctx.createLinearGradient(0, midY, 0, h - bottomMargin);
        grad.addColorStop(0, "rgba(255,255,255,0)");
        grad.addColorStop(1, colorNegative);
        ctx.fillStyle = grad;
        ctx.fill();
        
        ctx.strokeStyle = colorNegative.replace(/[\d.]+\)$/, '1)');
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();
        ctx.restore();

    } else {
        ctx.beginPath();
        ctx.moveTo(pts[0].x, h - bottomMargin);
        for (let p of pts) ctx.lineTo(p.x, p.y);
        ctx.lineTo(pts[pts.length-1].x, h - bottomMargin);
        ctx.closePath();

        let grad = ctx.createLinearGradient(0, topMargin, 0, h - bottomMargin);
        grad.addColorStop(0, colorPositive);
        grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) {
            if (i===0) ctx.moveTo(pts[i].x, pts[i].y);
            else ctx.lineTo(pts[i].x, pts[i].y);
        }
        ctx.strokeStyle = colorPositive.replace(/[\d.]+\)$/, '1)');
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();
    }

    if (data2 && data2.length > 1) {
        ctx.beginPath();
        for (let i = 0; i < data2.length; i++) {
            const px = leftMargin + i * stepX;
            const py = midY - (data2[i] * scaleY);
            if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = color2;
        ctx.lineWidth = 2 * scale;
        ctx.stroke();

        // Label for current value of data2
        const lastVal = data2[data2.length - 1];
        const py = midY - (lastVal * scaleY);
        ctx.fillStyle = color2.replace(/[\d.]+\)$/, '1)');
        ctx.font = "bold " + (6.5 * scale) + "px " + fontStack;
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        ctx.fillText(lastVal.toFixed(0), leftMargin - 6 * scale, py);
    }
}

function drawSignGraph(ctx, data, title) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const leftMargin = 44;
    const rightMargin = 8;
    const topMargin = 6;
    const bottomMargin = 6;

    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#444";
    ctx.fillText(title, leftMargin, 12);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    // Draw Y axis (small)
    ctx.strokeStyle = '#ccc';
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(leftMargin, h - bottomMargin);
    ctx.stroke();

    if (!data || data.length === 0) return;

    const stepX = plotW / Math.max(1, data.length - 1);

    for (let i = 0; i < data.length; i++) {
        const val = data[i];
        const px = leftMargin + i * stepX;
        const wRect = Math.max(1, Math.ceil(stepX));
        ctx.fillStyle = (val >= 0) ? 'rgba(0,160,0,0.5)' : 'rgba(220,0,0,0.45)';
        ctx.fillRect(px, topMargin, wRect, plotH);
    }

    // Draw a thin separator line at mid (zero) for clarity
    ctx.strokeStyle = '#eee';
    ctx.beginPath(); ctx.moveTo(leftMargin, topMargin + plotH/2); ctx.lineTo(w - rightMargin, topMargin + plotH/2); ctx.stroke();
}

function drawSustainabilityGauge(ctx, avgThrust, maxThrustRef) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const margin = 8;
    const gaugeW = w - 2 * margin;
    const gaugeH = h - 2 * margin;
    const centerX = margin + gaugeW / 2;
    const centerY = margin + gaugeH / 2;

    // Clamp avgThrust to reasonable range
    const clampedThrust = Math.max(-maxThrustRef, Math.min(maxThrustRef, avgThrust));
    const normalized = clampedThrust / maxThrustRef; // -1 to +1

    // Background bar (light gray)
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(margin, margin, gaugeW, gaugeH);

    // Split into left (negative/red) and right (positive/green) halves
    const halfW = gaugeW / 2;

    // Left half: negative/deceleration (red)
    ctx.fillStyle = 'rgba(255, 100, 100, 0.2)';
    ctx.fillRect(margin, margin, halfW, gaugeH);

    // Right half: positive/acceleration (green)
    ctx.fillStyle = 'rgba(100, 200, 100, 0.2)';
    ctx.fillRect(margin + halfW, margin, halfW, gaugeH);

    // Fill indicator based on normalized thrust
    if (normalized < 0) {
        // Deceleration: fill from center left
        const fillW = Math.abs(normalized) * halfW;
        ctx.fillStyle = 'rgba(220, 50, 50, 0.6)';
        ctx.fillRect(centerX - fillW, margin, fillW, gaugeH);
    } else {
        // Acceleration: fill from center right
        const fillW = normalized * halfW;
        ctx.fillStyle = 'rgba(80, 180, 80, 0.6)';
        ctx.fillRect(centerX, margin, fillW, gaugeH);
    }

    // Center line (zero)
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centerX, margin);
    ctx.lineTo(centerX, margin + gaugeH);
    ctx.stroke();

    // Border
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(margin, margin, gaugeW, gaugeH);

    // Label text
    ctx.fillStyle = '#333';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Decel', margin + 4, margin + 12);
    ctx.textAlign = 'right';
    ctx.fillText('Accel', w - margin - 4, margin + 12);

    // Show numeric value
    ctx.textAlign = 'center';
    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = (normalized >= 0) ? '#008000' : '#c00000';
    ctx.fillText(avgThrust.toFixed(0) + ' N', centerX, margin + gaugeH - 2);
}


// --- UPDATE & RENDER ---
function updatePhysicsState(dtOverride) {
    const dt = dtOverride || state.dt;
    
    // Increment the history timer
    state.historyTimer += dt;

    // Process history updates in fixed steps
    while (state.historyTimer >= state.dt) {
        // Decrement timer by one simulation step
        state.historyTimer -= state.dt;
        
        // Increment simulation time and recalculate physics for the history
        state.t += state.dt;
        if(state.t > 1000) state.t = 0; // Reset time to avoid precision issues
        
        const phys = calculatePhysics(state.t); // Recalculate for the new time
        
        // --- Update History Arrays ---
        state.liftHistory.push(phys.Lz);
        if (state.liftHistory.length > 1000) state.liftHistory.shift();
        
        state.thrustHistory.push(phys.thrust);
        if (state.thrustHistory.length > 1000) state.thrustHistory.shift();
        
        state.powerHistory.push(phys.rawPower);
        if (state.powerHistory.length > 1000) state.powerHistory.shift();
        
        // Calculate window (2 cycles) for smoothing
        const cyclePeriod = 1.0 / state.freq;
        const samplesPerCycle = Math.max(1, cyclePeriod / state.dt);
        const windowSize = Math.ceil(samplesPerCycle * 2);
        
        // Power (Normalized & Average)
        let sumFourthPower = 0;
        let sumPower = 0;
        const start = Math.max(0, state.powerHistory.length - windowSize);
        const count = state.powerHistory.length - start;
        for (let i = state.powerHistory.length - 1; i >= start; i--) {
            // Double Check: Ensure we only calculate positive work.
            // Clamp negative values (braking/absorbing) to 0 before averaging.
            const val = Math.max(0, state.powerHistory[i]);
            sumFourthPower += Math.pow(val, 4);
            sumPower += val;
        }
        const avgPower = (count > 0) ? Math.pow(sumFourthPower / count, 0.25) : 0;
        const arithmeticAvgPower = (count > 0) ? sumPower / count : 0;

        state.avgPowerHistory.push(avgPower);
        if (state.avgPowerHistory.length > 1000) state.avgPowerHistory.shift();
        state.arithmeticAvgPowerHistory.push(arithmeticAvgPower);
        if (state.arithmeticAvgPowerHistory.length > 1000) state.arithmeticAvgPowerHistory.shift();

        // Average Thrust (Windowed)
        let thrustSum = 0;
        const startThrust = Math.max(0, state.thrustHistory.length - windowSize);
        const countThrust = state.thrustHistory.length - startThrust;
        for (let i = state.thrustHistory.length - 1; i >= startThrust; i--) {
            thrustSum += state.thrustHistory[i];
        }
        const avgThrust = (countThrust > 0) ? thrustSum / countThrust : 0;
        state.avgThrustHistory.push(avgThrust);
        if (state.avgThrustHistory.length > 1000) state.avgThrustHistory.shift();

        // Average Lift (Windowed)
        let liftSum = 0;
        const startLift = Math.max(0, state.liftHistory.length - windowSize);
        const countLift = state.liftHistory.length - startLift;
        for (let i = state.liftHistory.length - 1; i >= startLift; i--) {
            liftSum += state.liftHistory[i];
        }
        const avgLift = (countLift > 0) ? liftSum / countLift : 0;
        state.avgLiftHistory.push(avgLift);
        if (state.avgLiftHistory.length > 1000) state.avgLiftHistory.shift();

        // Update the visual path of the foil (synced with physics steps)
        state.pathX.push(phys.x);
        state.pathZ.push(phys.z);
        if (state.pathX.length > 300) {
            state.pathX.shift();
            state.pathZ.shift();
        }
    }
    
    // Get the most recent averages for the UI display
    const currentAvgPower = state.avgPowerHistory.length > 0 ? state.avgPowerHistory[state.avgPowerHistory.length - 1] : 0;
    const currentArithmeticAvgPower = state.arithmeticAvgPowerHistory.length > 0 ? state.arithmeticAvgPowerHistory[state.arithmeticAvgPowerHistory.length - 1] : 0;
    const currentAvgThrust = state.avgThrustHistory.length > 0 ? state.avgThrustHistory[state.avgThrustHistory.length - 1] : 0;
    const currentAvgLift = state.avgLiftHistory.length > 0 ? state.avgLiftHistory[state.avgLiftHistory.length - 1] : 0;

    // Calculate smooth physics for rendering (interpolate time using the remainder)
    const smoothPhys = calculatePhysics(state.t + state.historyTimer);

    return { phys: smoothPhys, avgPower: currentAvgPower, arithmeticAvgPower: currentArithmeticAvgPower, avgThrust: currentAvgThrust, avgLift: currentAvgLift };
}

function render(data) {
    const { phys, avgPower, arithmeticAvgPower, avgThrust, avgLift } = data;

    // UI
    ui.time.textContent = state.t.toFixed(2);
    ui.speed.textContent = (CONFIG.U * 3.6).toFixed(1);
    
    // Update New Angle Displays
    ui.pitch.textContent = (phys.theta * 180 / Math.PI).toFixed(1);
    ui.aoa.textContent = (phys.alpha * 180 / Math.PI).toFixed(1);

    ui.watts.textContent = phys.power.toFixed(0);
    ui.arithAvgWatts.textContent = arithmeticAvgPower.toFixed(0);
    ui.avgWatts.textContent = avgPower.toFixed(0);
    
    // Canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const PPU = 100;
    const camX = phys.x * PPU;
    const camOffset = canvas.width / 3;
    
    ctx.save();
    ctx.translate(-camX + camOffset, canvas.height * 0.70);
    
    // Environment
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 1;
    ctx.beginPath();
    const startGrid = Math.floor((phys.x - 2)); const endGrid = Math.floor((phys.x + 8));
    for (let i = startGrid; i <= endGrid; i++) { ctx.moveTo(i * PPU, -500); ctx.lineTo(i * PPU, 500); }
    ctx.moveTo(-10000, 0); ctx.lineTo(10000, 0); ctx.stroke();
    
    // Water Surface
    const surfaceZ = 0.85 / 2; 
    const surfaceY = -surfaceZ * PPU;
    ctx.fillStyle = 'rgba(0, 160, 255, 0.1)';
    ctx.fillRect(camX - 2000, surfaceY, 4000, 1000);
    ctx.beginPath(); ctx.moveTo(camX - 2000, surfaceY); ctx.lineTo(camX + 2000, surfaceY);
    ctx.strokeStyle = 'rgba(0, 160, 255, 0.5)'; ctx.lineWidth = 2; ctx.stroke();

    // Trail
    ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
    for(let i=0; i<state.pathX.length; i++){
        const px = state.pathX[i] * PPU; const pz = -state.pathZ[i] * PPU;
        if (i===0) ctx.moveTo(px, pz); else ctx.lineTo(px, pz);
    }
    // Connect trail to current foil position to close the gap
    if (state.pathX.length > 0) {
        ctx.lineTo(phys.x * PPU, -phys.z * PPU);
    }
    ctx.stroke();
    
    const foilCX = phys.x * PPU; const foilCY = -phys.z * PPU;
    
    // Foil
    // Foil Assembly (Rigid Body)
    ctx.save(); ctx.translate(foilCX, foilCY); ctx.rotate(-phys.theta); 
    
    // Dimensions
    const mastH = 0.85 * PPU;
    const mastW = 0.06 * PPU;
    const fuseLen = 0.9 * PPU;
    const fuseRad = 0.015 * PPU;
    const mastX = -0.15 * PPU; 
    const boardL = 1.4 * PPU;
    const boardThick = 0.08 * PPU;

    if (VISIBILITY.assembly) {
        // 1. Mast & Fuselage & Stabilizer
        ctx.fillStyle = '#444';
        
        // Fuselage (extending backwards from wing)
        ctx.fillRect(-fuseLen + 0.1*PPU, -fuseRad, fuseLen, fuseRad*2);
        // Stabilizer (at the back)
        ctx.beginPath(); ctx.ellipse(-fuseLen + 0.15*PPU, 0, 0.12*PPU, 0.015*PPU, 0, 0, Math.PI*2); ctx.fill();
        // Mast (extending up)
        ctx.fillRect(mastX - mastW/2, -mastH, mastW, mastH);

        // 2. Board (on top of mast)
        ctx.fillStyle = '#ccc'; ctx.strokeStyle = '#999';
        ctx.beginPath(); ctx.rect(mastX - boardL/3, -mastH - boardThick, boardL, boardThick);
        ctx.fill(); ctx.stroke();
    }

    // 3. Stickman Rider
    if (VISIBILITY.rider && VISIBILITY.assembly) {
        const fatness = CONFIG.mass / 80.0;
        const limbWidth = 5 * fatness;
        const torsoWidth = 12 * fatness * fatness;

        // Color change for Power Phase
        // Light up when pushing down (Rz < 0) and accelerating downwards (az < 0)
        const isPowerPhase = (phys.power>0);
        const riderColor = isPowerPhase ? '#f97316' : '#222'; // Orange-500 if powered

        ctx.strokeStyle = riderColor; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        const deckY = -mastH - boardThick;
        const legLen = 0.9 * PPU;
        const torsoLen = 0.55 * PPU;
        const headRad = 0.1 * PPU * Math.sqrt(fatness);
        
        // Crouch: z high (up) -> crouch=1 (bent). z low (down) -> crouch=0 (straight)
        const normZ = (state.heave_amp > 0.0001) ? Math.max(-1, Math.min(1, phys.z / state.heave_amp)) : 0;
        const crouch = (normZ + 1) / 2; 
        
        const curLegLen = legLen * (1.0 - 0.35 * crouch);
        
        // Feet positions (Fixed on board)
        const footRearX = mastX;
        const footFrontX = mastX + 0.4 * PPU;

        // Hip stabilized over front foot (World Up)
        const sinT = Math.sin(phys.theta);
        const cosT = Math.cos(phys.theta);
        
        const hipX = footFrontX + curLegLen * sinT;
        const hipY = deckY - curLegLen * cosT;
        
        const kneeBend = 0.25 * PPU * crouch;

        // Legs
        ctx.lineWidth = limbWidth;
        ctx.beginPath(); ctx.moveTo(footRearX, deckY); ctx.quadraticCurveTo(footRearX + (hipX - footRearX)/2 + kneeBend, deckY - curLegLen/2, hipX, hipY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(footFrontX, deckY); ctx.quadraticCurveTo(footFrontX + (hipX - footFrontX)/2 + kneeBend, deckY - curLegLen/2, hipX, hipY); ctx.stroke();
        
        // Torso & Head (Upright in World Space)
        const shoulderX = hipX + torsoLen * sinT;
        const shoulderY = hipY - torsoLen * cosT;

        ctx.lineWidth = torsoWidth;
        ctx.beginPath(); ctx.moveTo(hipX, hipY); ctx.lineTo(shoulderX, shoulderY); ctx.stroke();
        ctx.beginPath(); ctx.fillStyle='#eee'; ctx.lineWidth=2; ctx.arc(shoulderX, shoulderY - headRad, headRad, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        
        // Arms
        const armDx = 0.45 * PPU;
        const armDy = 0.15 * PPU;
        const rArmX = shoulderX + (armDx * cosT - armDy * sinT);
        const rArmY = shoulderY + (armDx * sinT + armDy * cosT);
        const lArmX = shoulderX - (armDx * cosT + armDy * sinT);
        const lArmY = shoulderY + (-armDx * sinT + armDy * cosT);

        ctx.lineWidth = limbWidth;
        ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(rArmX, rArmY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(lArmX, lArmY); ctx.stroke();
    }

    // 3. Main Wing (NACA Profile) - Centered at (0,0)
    const chordPx = CONFIG.visual_size_m * PPU;
    const toLocalX = (nx) => (0.25 - nx) * chordPx; 
    ctx.beginPath(); ctx.fillStyle = 'black';
    ctx.moveTo(toLocalX(foilShape[0].x), -foilShape[0].y * chordPx);
    for (let i = 1; i < foilShape.length; i++) ctx.lineTo(toLocalX(foilShape[i].x), -foilShape[i].y * chordPx);
    for (let i = foilShape.length - 1; i >= 0; i--) ctx.lineTo(toLocalX(foilShape[i].x), foilShape[i].y * chordPx);
    ctx.fill(); ctx.restore();

    // Vectors
    const vecScale = 0.2; 
    if (VISIBILITY.lift) drawArrow(ctx, foilCX, foilCY, phys.Lx, phys.Lz, 'blue', vecScale, CONFIG.scale_L);
    if (VISIBILITY.drag) drawArrow(ctx, foilCX, foilCY, phys.Dx, phys.Dz, 'red', vecScale, CONFIG.scale_D);
    if (VISIBILITY.rider) {
        // Only draw if there is significant force
        if (Math.abs(phys.Rz) > 1) {
            drawArrow(ctx, foilCX, foilCY, phys.Rx, phys.Rz, 'orange', vecScale, CONFIG.scale_R);
        }
    }
    if (VISIBILITY.net) drawArrow(ctx, foilCX, foilCY, phys.Nx, phys.Nz, 'green', vecScale, CONFIG.scale_N);
    if (VISIBILITY.thrust) drawArrow(ctx, foilCX, foilCY, phys.thrust, 0, 'cyan', vecScale, CONFIG.scale_T);

    ctx.restore();
    
    // Graphs
    drawSimpleGraph(ctxLift, state.liftHistory, "Vertical Lift (N)", "rgba(59, 130, 246, 0.5)", "rgba(239, 68, 68, 0.5)");
    drawSimpleGraph(ctxThrust, state.thrustHistory, "Net Thrust (N)", "rgba(16, 185, 129, 0.5)", "rgba(244, 63, 94, 0.5)");
    drawSimpleGraph(ctxPower, state.powerHistory, "Rider Inst. Power (W)", "rgba(245, 158, 11, 0.5)", "rgba(168, 85, 247, 0.5)");
    drawSimpleGraph(ctxAvgPower, state.avgPowerHistory, "Norm (Org) vs Avg (Blu) Power (W)", "rgba(249, 115, 22, 0.5)", null, state.arithmeticAvgPowerHistory, "rgba(59, 130, 246, 0.8)");

    // Update avg lift status bar
    const weight = CONFIG.mass * CONFIG.g;
    const liftStatusEl = document.getElementById('avgLiftStatus');
    const liftDiff = avgLift - weight;
    
    if (liftDiff < -20) { // Tolerance of 20N
        liftStatusEl.style.backgroundColor = '#ffcdd2';
        liftStatusEl.style.color = '#b71c1c';
        liftStatusEl.textContent = `Avg Lift: Sinking (${avgLift.toFixed(0)} N < ${weight.toFixed(0)} N)`;
    } else if (liftDiff > 20) {
        liftStatusEl.style.backgroundColor = '#bbdefb';
        liftStatusEl.style.color = '#0d47a1';
        liftStatusEl.textContent = `Avg Lift: Climbing (${avgLift.toFixed(0)} N > ${weight.toFixed(0)} N)`;
    } else {
        liftStatusEl.style.backgroundColor = '#c8e6c9';
        liftStatusEl.style.color = '#1b5e20';
        liftStatusEl.textContent = `Avg Lift: Balanced (~${weight.toFixed(0)} N)`;
    }

    // Update avg thrust status bar
    ui.avgThrust.textContent = avgThrust.toFixed(0);
    const statusEl = document.getElementById('avgThrustStatus');
    if (avgThrust < -2) {
        statusEl.style.backgroundColor = '#ffcdd2';
        statusEl.style.color = '#b71c1c';
        statusEl.textContent = 'Avg Thrust: Decelerating : ' + avgThrust.toFixed(0) + ' N';
    } else if (avgThrust > 2) {
        statusEl.style.backgroundColor = '#bbdefb';
        statusEl.style.color = '#0d47a1';
        statusEl.textContent = 'Avg Thrust: Accelerating : ' + avgThrust.toFixed(0) + ' N';
    } else {
        statusEl.style.backgroundColor = '#c8e6c9';
        statusEl.style.color = '#1b5e20';
        statusEl.textContent = 'Avg Thrust: On Target : ' + avgThrust.toFixed(0) + ' N';
    }
    
}

// --- LISTENERS ---
document.getElementById('in-freq').addEventListener('input', (e) => { state.freq = parseFloat(e.target.value); ui.dispFreq.textContent = state.freq.toFixed(2); });
document.getElementById('in-amp').addEventListener('input', (e) => { state.heave_amp = parseFloat(e.target.value); ui.dispAmp.textContent = state.heave_amp.toFixed(2); });
document.getElementById('in-size').addEventListener('input', (e) => { CONFIG.visual_size_m = parseFloat(e.target.value); ui.dispSize.textContent = CONFIG.visual_size_m.toFixed(2); });
document.getElementById('in-speed').addEventListener('input', (e) => { const kph = parseFloat(e.target.value); CONFIG.U = kph / 3.6; ui.dispSpeed.textContent = kph.toFixed(1); });
document.getElementById('in-mass').addEventListener('input', (e) => { CONFIG.mass = parseFloat(e.target.value); ui.dispMass.textContent = CONFIG.mass.toFixed(0); });
document.getElementById('in-area').addEventListener('input', (e) => { const cm2 = parseFloat(e.target.value); CONFIG.S = cm2 / 10000; ui.dispArea.textContent = cm2.toFixed(0); });
document.getElementById('in-ar').addEventListener('input', (e) => { CONFIG.AR = parseFloat(e.target.value); ui.dispAr.textContent = CONFIG.AR.toFixed(1); });
document.getElementById('in-cd0').addEventListener('input', (e) => { CONFIG.Cd0 = parseFloat(e.target.value); ui.dispCd0.textContent = CONFIG.Cd0.toFixed(3); });
document.getElementById('in-trim').addEventListener('input', (e) => { CONFIG.pitch_trim_deg = parseFloat(e.target.value); ui.dispTrim.textContent = CONFIG.pitch_trim_deg.toFixed(1); });
document.getElementById('in-phase').addEventListener('input', (e) => { CONFIG.phase_shift_deg = parseFloat(e.target.value); ui.dispPhase.textContent = CONFIG.phase_shift_deg.toFixed(0); });
document.getElementById('in-swing').addEventListener('input', (e) => { CONFIG.swing_weight_ratio = parseFloat(e.target.value); ui.dispSwing.textContent = (CONFIG.swing_weight_ratio * 100).toFixed(0); });
document.getElementById('chk-slowmo').addEventListener('change', (e) => { state.slowMotion = e.target.checked; });

document.getElementById('btn-reset').addEventListener('click', () => {
    state.freq = 1.65; document.getElementById('in-freq').value = 1.65; ui.dispFreq.textContent = "1.65";
    state.heave_amp = 0.13; document.getElementById('in-amp').value = 0.13; ui.dispAmp.textContent = "0.13";
    CONFIG.U = 20.0 / 3.6; document.getElementById('in-speed').value = 20.0; ui.dispSpeed.textContent = "20.0";
    CONFIG.mass = 70.0; document.getElementById('in-mass').value = 70; ui.dispMass.textContent = "70";
    CONFIG.S = 0.135; document.getElementById('in-area').value = 1350; ui.dispArea.textContent = "1350";
    CONFIG.AR = 13.9; document.getElementById('in-ar').value = 13.9; ui.dispAr.textContent = "13.9";
    CONFIG.Cd0 = 0.015; document.getElementById('in-cd0').value = 0.015; ui.dispCd0.textContent = "0.015";
    CONFIG.pitch_trim_deg = 3.3; document.getElementById('in-trim').value = 3.3; ui.dispTrim.textContent = "3.3";
    CONFIG.phase_shift_deg = 90.0; document.getElementById('in-phase').value = 90; ui.dispPhase.textContent = "90";
    CONFIG.swing_weight_ratio = 0.4; document.getElementById('in-swing').value = 0.4; ui.dispSwing.textContent = "40";
    CONFIG.visual_size_m = 0.4; document.getElementById('in-size').value = 0.4; ui.dispSize.textContent = "0.40";
    state.slowMotion = false; document.getElementById('chk-slowmo').checked = false;
    
    // Clear history for clean restart
    state.liftHistory = []; state.thrustHistory = []; state.powerHistory = []; state.avgPowerHistory = []; state.arithmeticAvgPowerHistory = []; state.avgThrustHistory = []; state.avgLiftHistory = [];
});

document.getElementById('btn-replay').addEventListener('click', () => {
    state.t = 0;
    state.historyTimer = 0;
    state.liftHistory = [];
    state.thrustHistory = [];
    state.powerHistory = [];
    state.avgPowerHistory = [];
    state.arithmeticAvgPowerHistory = [];
    state.avgThrustHistory = [];
    state.avgLiftHistory = [];
    state.pathX = [];
    state.pathZ = [];
    state.paused = false;
    render({ phys: calculatePhysics(0), avgPower: 0, arithmeticAvgPower: 0, avgThrust: 0, avgLift: 0 });
});

document.getElementById('chk-lift').addEventListener('change', (e) => VISIBILITY.lift = e.target.checked);
document.getElementById('chk-drag').addEventListener('change', (e) => VISIBILITY.drag = e.target.checked);
document.getElementById('chk-rider').addEventListener('change', (e) => VISIBILITY.rider = e.target.checked);
document.getElementById('chk-net').addEventListener('change', (e) => VISIBILITY.net = e.target.checked);
document.getElementById('chk-thrust').addEventListener('change', (e) => VISIBILITY.thrust = e.target.checked);
document.getElementById('chk-assembly').addEventListener('change', (e) => VISIBILITY.assembly = e.target.checked);

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') state.paused = !state.paused;
    if (state.paused) {
        if (e.code === 'ArrowRight') render(updatePhysicsState());
        if (e.code === 'ArrowLeft') {
            if (state.thrustHistory.length > 0) {
                state.liftHistory.pop();
                state.thrustHistory.pop();
                state.powerHistory.pop();
                state.avgPowerHistory.pop();
                state.arithmeticAvgPowerHistory.pop();
                state.avgThrustHistory.pop();
                state.avgLiftHistory.pop();
                state.pathX.pop();
                state.pathZ.pop();

                state.t -= state.dt;
                state.historyTimer = 0;

                render({ 
                    phys: calculatePhysics(state.t), 
                    avgPower: state.avgPowerHistory[state.avgPowerHistory.length-1] || 0, 
                    arithmeticAvgPower: state.arithmeticAvgPowerHistory[state.arithmeticAvgPowerHistory.length-1] || 0,
                    avgThrust: state.avgThrustHistory[state.avgThrustHistory.length-1] || 0,
                    avgLift: state.avgLiftHistory[state.avgLiftHistory.length-1] || 0
                });
            }
        }
    }
});

let lastTime = 0;
function loop(timestamp) {
    if (!timestamp) {
        requestAnimationFrame(loop);
        return;
    }
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (!state.paused) {
        const safeDt = Math.min(dt, 0.1);
        const simDt = state.slowMotion ? safeDt * 0.2 : safeDt;
        render(updatePhysicsState(simDt));
    }
    requestAnimationFrame(loop);
}

render({ phys: calculatePhysics(0), avgPower: 0, arithmeticAvgPower: 0, avgThrust: 0, avgLift: 0 });
loop();

</script>
</body>
</html>