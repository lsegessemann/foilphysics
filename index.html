<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pump Foil Simulator (Angle Telemetry)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            overflow: auto;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            max-width: 900px;
        }

        .canvas-wrapper {
            position: relative;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
            width: 100%;
            height: auto;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            pointer-events: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            min-width: 200px;
            z-index: 10;
        }

        #controls {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 240px;
            box-sizing: border-box;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 110px;
        }

        label {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
        }

        input[type=range] {
            height: 4px;
        }

        /* LEGEND STYLES */
        .legend-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .legend-title {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .legend-items { display: flex; flex-direction: column; gap: 6px; font-size: 11px; }
        .legend-item { display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        input[type=checkbox] { cursor: pointer; }
        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-size: 9px;
            font-weight: 700;
        }

        #dashboard-row {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 10px;
            width: 100%;
        }
        #graphs-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }

        /* Make graphs fill the available height to align with controls */
        #graphs-column .canvas-wrapper:not(#avgThrustStatus) {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        #graphs-column .canvas-wrapper:not(#avgThrustStatus) canvas {
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            #dashboard-row {
                flex-direction: column;
            }
            #controls {
                width: 100%;
                display: grid;
                grid-template-columns: 1fr 1fr;
            }
            #ui-overlay {
                font-size: 11px;
                padding: 10px;
                min-width: 140px;
                right: 10px;
                top: 10px;
            }
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div class="canvas-wrapper">
            <canvas id="simCanvas" width="900" height="380"></canvas>
            <div id="ui-overlay">
                <strong>Live Telemetry</strong><br>
                Time: <span id="val-time">0.00</span> s<br>
                Speed: <span id="val-speed">18.0</span> km/h<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Pitch (vs Horizon): <span id="val-pitch">0.0</span>°<br>
                AoA (vs Water): <span id="val-aoa">0.0</span>°<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Inst. Power: <span id="val-watts">0</span> W<br>
                Avg. Power: <span id="val-avg-watts">0</span> W
            </div>
        </div>

        <div id="dashboard-row">
            <div id="graphs-column">
                <div class="canvas-wrapper">
                    <canvas id="graphThrust" width="650" height="90"></canvas>
                </div>
                <div class="canvas-wrapper" id="avgThrustStatus" style="padding: 10px; text-align: center; font-size: 14px; font-weight: bold; background-color: #e8f5e9;">
                    Avg Thrust: Accelerating : <span id="val-avg-thrust">0</span> N
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphPower" width="650" height="90"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphAvgPower" width="650" height="90"></canvas>
                </div>
                <div style="font-size: 10px; color: #555; background: #fff; padding: 10px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); line-height: 1.4;">
                    <strong>Drag Coefficient: Cd0 Reference:</strong><br>
                    <b>0.01 - 0.02 (High-Efficiency):</b><br>
                    Very thin, high-modulus carbon masts (reduced frontal area).<br>
                    Thinner wing profiles.<br>
                    <b>0.02 - 0.025 (Standard Pump Foil):</b><br>
                    Typical high-quality setups<br>
                    Standard mast thickness (~15-19mm).<br>
                    <b>0.025 - 0.035 (Beginner / Draggy):</b><br>
                    Thick aluminum masts.<br>
                    Low-aspect, thick beginner wings.
                </div>
            </div>
            
            <div id="controls">
            <div class="control-group">
                <label>Frequency: <span id="disp-freq">0.8</span> Hz</label>
                <input type="range" id="in-freq" min="0.01" max="2.5" step="0.01" value="0.8">
            </div>
            <div class="control-group">
                <label>Amplitude: <span id="disp-amp">0.22</span> m</label>
                <input type="range" id="in-amp" min="0.00" max="0.30" step="0.01" value="0.22">
            </div>
            <div class="control-group">
                <label>Speed: <span id="disp-speed">15.0</span> km/h</label>
                <input type="range" id="in-speed" min="10.0" max="30.0" step="1.0" value="15.0">
            </div>
            <div class="control-group">
                <label>Mass: <span id="disp-mass">80</span> kg</label>
                <input type="range" id="in-mass" min="40" max="120" step="1" value="80">
            </div>
            <div class="control-group">
                <label>Wing Area: <span id="disp-area">1500</span> cm²</label>
                <input type="range" id="in-area" min="600" max="2000" step="50" value="1500">
            </div>
            <div class="control-group">
                <label>Aspect Ratio: <span id="disp-ar">13.0</span></label>
                <input type="range" id="in-ar" min="5.0" max="20.0" step="0.1" value="13.0">
            </div>
            <div class="control-group">
                <label>Drag Coeff (Cd0): <span id="disp-cd0">0.020</span></label>
                <input type="range" id="in-cd0" min="0.010" max="0.035" step="0.001" value="0.020">
            </div>
            <div class="control-group">
                <label>Frontwing Pitch Trim: <span id="disp-trim">1.0</span>°</label>
                <input type="range" id="in-trim" min="-5.0" max="10.0" step="0.5" value="1.0">
            </div>
            <div class="control-group">
                <label>Phase Shift: <span id="disp-phase">90</span>°</label>
                <input type="range" id="in-phase" min="0" max="180" step="5" value="90">
            </div>
            <div class="control-group">
                <label>Visualization Scale: <span id="disp-size">0.40</span></label>
                <input type="range" id="in-size" min="0.10" max="1.0" step="0.05" value="0.4">
            </div>
            <div class="control-group" style="flex-direction: row; align-items: center; gap: 6px; margin-top: 4px;">
                <input type="checkbox" id="chk-slowmo" style="height: auto;">
                <label for="chk-slowmo" style="margin: 0; cursor: pointer;">Slow Motion (1/5x)</label>
            </div>
            
            <button id="btn-reset" style="margin-top: 5px; padding: 4px; cursor: pointer; font-size: 10px; font-weight: bold; background: #eee; border: 1px solid #ccc; border-radius: 4px;">RESET DEFAULTS</button>

            <div class="legend-container">
                <div class="legend-title">Visibility</div>
                <div class="legend-items">
                    <label class="legend-item"><input type="checkbox" id="chk-lift" checked><div class="dot" style="background: blue;"></div> Lift Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-drag" checked><div class="dot" style="background: red;"></div> Drag Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-rider" checked><div class="dot" style="background: orange;"></div> Rider Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-net"><div class="dot" style="background: green;"></div> Net Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-thrust" checked><div class="dot" style="background: cyan; border:1px solid #999;"></div> Thrust Force Vector</label>
                    <label class="legend-item"><input type="checkbox" id="chk-assembly" checked><div class="dot" style="background: #666;"></div> Foilboard and Rider </label>
                </div>
                <div style="font-size: 9px; color: #555; margin-top: 5px;">
                    <kbd>SPACE</kbd> Pause
                </div>
            </div>
        </div>
        </div>
    </div>

<script>
/**
 * PUMP FOIL SIMULATOR
 */

// --- CONFIGURATION ---
const CONFIG = {
    mass: 80.0,          // Total mass (Rider + Board) in kg
    U: 15.0 / 3.6,       // Forward speed in m/s (converted from km/h)
    rho: 1000.0,         // Water density in kg/m³
    S: 0.15,             // Wing Area in m² (1500 cm²)
    Cd0: 0.02,           // Parasitic Drag Coefficient (0.015=Pro, 0.02=Std, 0.03=Draggy)
    k: 0.05,             // Induced Drag Factor (recalculated based on AR)
    g: 9.81,             // Gravity (m/s²)
    visual_size_m: 0.4,  // Visual scale for foil chord length
    // Scales
    scale_L: 0.5, scale_D: 5.0, scale_T: 5.0, scale_R: 0.5, scale_N: 0.5,
    AR: 13.0,            // Aspect Ratio (Span² / Area)
    
    // Adjustable Parameters
    pitch_trim_deg: 1.0,    // Base pitch angle in degrees
    phase_shift_deg: 90.0   // Phase difference between Heave and Pitch
};

// --- VISIBILITY STATE ---
const VISIBILITY = { lift: true, drag: true, rider: true, net: false, thrust: true, assembly: true };

// --- STATE ---
let state = {
    t: 0,
    dt: 0.01,
    historyTimer: 0,
    paused: false,
    slowMotion: false,
    freq: 0.8,
    heave_amp: 0.22,
    pathX: [],
    pathZ: [],
    thrustHistory: [],
    avgThrustHistory: [],
    powerHistory: [],
    avgPowerHistory: []
};

// --- NACA PROFILE ---
function getNACA00xx(thickness, points) {
    const coords = [];
    for (let i = 0; i <= points; i++) {
        const beta = (i / points) * Math.PI;
        const x = (1 - Math.cos(beta)) / 2;
        const yt = 5 * thickness * (0.2969 * Math.sqrt(x) - 0.1260 * x - 0.3516 * Math.pow(x, 2) + 0.2843 * Math.pow(x, 3) - 0.1015 * Math.pow(x, 4));
        coords.push({x: x, y: yt});
    }
    return coords;
}
const foilShape = getNACA00xx(0.15, 40);

// --- DOM ELEMENTS ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const ctxThrust = document.getElementById('graphThrust').getContext('2d');
const ctxPower = document.getElementById('graphPower').getContext('2d');
const ctxAvgPower = document.getElementById('graphAvgPower').getContext('2d');

const ui = {
    time: document.getElementById('val-time'),
    speed: document.getElementById('val-speed'),
    watts: document.getElementById('val-watts'),
    avgWatts: document.getElementById('val-avg-watts'),
    avgThrust: document.getElementById('val-avg-thrust'),
    
    // Angle Displays
    pitch: document.getElementById('val-pitch'),
    aoa: document.getElementById('val-aoa'),
    
    dispFreq: document.getElementById('disp-freq'),
    dispAmp: document.getElementById('disp-amp'),
    dispSize: document.getElementById('disp-size'),
    dispSpeed: document.getElementById('disp-speed'),
    dispMass: document.getElementById('disp-mass'),
    dispArea: document.getElementById('disp-area'),
    dispAr: document.getElementById('disp-ar'),
    dispCd0: document.getElementById('disp-cd0'),
    dispTrim: document.getElementById('disp-trim'),
    dispPhase: document.getElementById('disp-phase')
};

// --- PHYSICS ENGINE ---
function calculatePhysics(t) {
    const omega = 2 * Math.PI * state.freq;
    
    // 1. Amplitudes & Setup
    const vz_max = state.heave_amp * omega;
    const gamma_max = Math.atan2(vz_max, CONFIG.U);
    const pitch_amp = gamma_max * 0.90; 
    
    const pitch_trim = CONFIG.pitch_trim_deg * (Math.PI / 180);
    const phase_rad = CONFIG.phase_shift_deg * (Math.PI / 180);

    // 2. Motion (Time-based)
    // Heave: Cosine (Starts at top)
    const z = state.heave_amp * Math.cos(omega * t);
    
    // Heave Derivatives
    const vz = -state.heave_amp * omega * Math.sin(omega * t);
    const az = -state.heave_amp * (omega ** 2) * Math.cos(omega * t);
    
    // Pitch: Uses Phase Shift relative to Heave
    const theta = pitch_trim + pitch_amp * Math.cos(omega * t + phase_rad);

    // 3. Angles & Velocities
    const x = CONFIG.U * t;
    const vx = CONFIG.U;
    
    const gamma = Math.atan2(vz, vx);
    const alpha = theta - gamma;
    const v_sq = vx*vx + vz*vz;
    
    // 4. Forces
    // Finite wing correction: Cl = 2*pi*alpha / (1 + 2/AR)
    const Cl = (2 * Math.PI * alpha) / (1 + 2 / CONFIG.AR);
    // Induced drag factor k approx 1 / (pi * AR)
    const k = 1 / (Math.PI * CONFIG.AR);
    const Cd = CONFIG.Cd0 + k * (Cl * Cl);
    
    const L_mag = 0.5 * CONFIG.rho * CONFIG.S * Cl * v_sq;
    const D_mag = 0.5 * CONFIG.rho * CONFIG.S * Cd * v_sq;
    
    const Lx = -L_mag * Math.sin(gamma); const Lz = L_mag * Math.cos(gamma);
    const Dx = -D_mag * Math.cos(gamma); const Dz = -D_mag * Math.sin(gamma);
    
    // 5. Rider Force & Power
    // F_rider = F_Inertia - F_Hydro
    const F_inertia = CONFIG.mass * (CONFIG.g + az);
    const F_hydro_z = Lz + Dz;
    const F_rider_z = F_hydro_z - F_inertia;
    
    const power = Math.max(0, F_rider_z * (-vz));

    // 6. Vector Components
    const Rx = 0; const Rz = F_rider_z;
    const Nx = Lx + Dx + Rx; const Nz = Lz + Dz - Rz; 
    
    return {
        x, z, alpha, gamma, theta, vz,
        Lx, Lz, Dx, Dz, Rx, Rz, Nx, Nz,
        thrust: Lx + Dx, 
        riderForce: F_rider_z,
        power: power
    };
}
 
// --- DRAWING ---
function drawArrow(ctx, startX, startY, u, v, color, scale, user_scale) {
    let len = Math.sqrt(u*u + v*v) * scale * user_scale;
    const MAX_LEN_PX = 150;
    let clamp = 1.0;
    if (len > MAX_LEN_PX) clamp = MAX_LEN_PX / len;
    const finalU = u * scale * user_scale * clamp;
    const finalV = v * scale * user_scale * clamp;
    const endX = startX + finalU;
    const endY = startY - finalV; 
    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
    ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke();
    const angle = Math.atan2(-finalV, finalU); const headLen = 10;
    ctx.beginPath(); ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
    ctx.fillStyle = color; ctx.fill();
}

function drawSimpleGraph(ctx, data, title, colorPositive, colorNegative) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const leftMargin = 44;
    const rightMargin = 8;
    const topMargin = 18;
    const bottomMargin = 12;

    ctx.font = "bold 10px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
    ctx.fillStyle = "#666";
    ctx.fillText(title, leftMargin, 12);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    // Draw Y axis
    ctx.strokeStyle = '#ccc';
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(leftMargin, h - bottomMargin);
    ctx.stroke();

    if (data.length < 2) return;

    // Dynamic scaling: find max magnitude (for signed) or max value (for unsigned)
    let maxVal;
    if (colorNegative) {
        maxVal = Math.max(...data.map(v => Math.abs(v)));
    } else {
        maxVal = Math.max(...data);
    }
    if (!isFinite(maxVal) || maxVal <= 0) maxVal = 1;
    // Add a small padding so the line never touches the top
    maxVal *= 1.08;

    const midY = colorNegative ? (topMargin + plotH / 2) : (topMargin + plotH);
    const scaleY = colorNegative ? (plotH / 2) / maxVal : (plotH) / maxVal;

    // Draw horizontal zero (or baseline) line
    ctx.strokeStyle = '#eee';
    ctx.beginPath(); ctx.moveTo(leftMargin, midY); ctx.lineTo(w - rightMargin, midY); ctx.stroke();

    // Y labels: top, mid (zero if signed), bottom
    ctx.fillStyle = '#666';
    ctx.font = '11px sans-serif';
    if (colorNegative) {
        ctx.fillText(maxVal.toFixed(0), 6, topMargin + 10);
        ctx.fillText('0', 8, midY + 4);
        ctx.fillText((-maxVal).toFixed(0), 6, h - bottomMargin);
    } else {
        ctx.fillText(maxVal.toFixed(0), 6, topMargin + 10);
        ctx.fillText('0', 8, h - bottomMargin);
    }

    // Plot area and line
    const stepX = plotW / Math.max(1, data.length - 1);

    // Build points
    const pts = [];
    for (let i = 0; i < data.length; i++) {
        const val = data[i];
        const px = leftMargin + i * stepX;
        const py = midY - (val * scaleY);
        pts.push({px, py});
    }

    // Build polygon path that closes down to the baseline (midY)
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py);
    }
    ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
    ctx.lineTo(leftMargin, midY);
    ctx.closePath();

    // Fill only the area enclosed by the curve and the baseline.
    // For signed graphs (colorNegative provided) fill positive and negative sides separately
    if (colorNegative) {
        // Positive area (curve above baseline): intersect polygon with rect above midY
        ctx.save();
        // Clip to polygon
        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) { const p = pts[i]; if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py); }
        ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
        ctx.lineTo(leftMargin, midY);
        ctx.closePath();
        ctx.clip();
        // Intersect with rectangle above midY
        ctx.beginPath(); ctx.rect(leftMargin, topMargin, plotW, Math.max(0, midY - topMargin)); ctx.clip();
        ctx.fillStyle = colorPositive || 'rgba(0,0,0,0.15)';
        ctx.fillRect(leftMargin, topMargin, plotW, Math.max(0, midY - topMargin));
        ctx.restore();

        // Negative area (curve below baseline): intersect polygon with rect below midY
        ctx.save();
        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) { const p = pts[i]; if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py); }
        ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
        ctx.lineTo(leftMargin, midY);
        ctx.closePath();
        ctx.clip();
        ctx.beginPath(); ctx.rect(leftMargin, midY, plotW, Math.max(0, (h - bottomMargin) - midY)); ctx.clip();
        ctx.fillStyle = colorNegative || 'rgba(255,0,0,0.15)';
        ctx.fillRect(leftMargin, midY, plotW, Math.max(0, (h - bottomMargin) - midY));
        ctx.restore();
    } else {
        // Single-sided fill: clip to polygon and fill
        ctx.save();
        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) { const p = pts[i]; if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py); }
        ctx.lineTo(leftMargin + (pts.length - 1) * stepX, midY);
        ctx.lineTo(leftMargin, midY);
        ctx.closePath();
        ctx.clip();
        ctx.fillStyle = colorPositive || 'rgba(0,0,0,0.15)';
        ctx.fillRect(leftMargin, topMargin, plotW, plotH);
        ctx.restore();
    }

    // Stroke the line on top
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py);
    }
    ctx.stroke();
}

function drawSignGraph(ctx, data, title) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const leftMargin = 44;
    const rightMargin = 8;
    const topMargin = 6;
    const bottomMargin = 6;

    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#444";
    ctx.fillText(title, leftMargin, 12);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    // Draw Y axis (small)
    ctx.strokeStyle = '#ccc';
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(leftMargin, h - bottomMargin);
    ctx.stroke();

    if (!data || data.length === 0) return;

    const stepX = plotW / Math.max(1, data.length - 1);

    for (let i = 0; i < data.length; i++) {
        const val = data[i];
        const px = leftMargin + i * stepX;
        const wRect = Math.max(1, Math.ceil(stepX));
        ctx.fillStyle = (val >= 0) ? 'rgba(0,160,0,0.5)' : 'rgba(220,0,0,0.45)';
        ctx.fillRect(px, topMargin, wRect, plotH);
    }

    // Draw a thin separator line at mid (zero) for clarity
    ctx.strokeStyle = '#eee';
    ctx.beginPath(); ctx.moveTo(leftMargin, topMargin + plotH/2); ctx.lineTo(w - rightMargin, topMargin + plotH/2); ctx.stroke();
}

function drawSustainabilityGauge(ctx, avgThrust, maxThrustRef) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const margin = 8;
    const gaugeW = w - 2 * margin;
    const gaugeH = h - 2 * margin;
    const centerX = margin + gaugeW / 2;
    const centerY = margin + gaugeH / 2;

    // Clamp avgThrust to reasonable range
    const clampedThrust = Math.max(-maxThrustRef, Math.min(maxThrustRef, avgThrust));
    const normalized = clampedThrust / maxThrustRef; // -1 to +1

    // Background bar (light gray)
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(margin, margin, gaugeW, gaugeH);

    // Split into left (negative/red) and right (positive/green) halves
    const halfW = gaugeW / 2;

    // Left half: negative/deceleration (red)
    ctx.fillStyle = 'rgba(255, 100, 100, 0.2)';
    ctx.fillRect(margin, margin, halfW, gaugeH);

    // Right half: positive/acceleration (green)
    ctx.fillStyle = 'rgba(100, 200, 100, 0.2)';
    ctx.fillRect(margin + halfW, margin, halfW, gaugeH);

    // Fill indicator based on normalized thrust
    if (normalized < 0) {
        // Deceleration: fill from center left
        const fillW = Math.abs(normalized) * halfW;
        ctx.fillStyle = 'rgba(220, 50, 50, 0.6)';
        ctx.fillRect(centerX - fillW, margin, fillW, gaugeH);
    } else {
        // Acceleration: fill from center right
        const fillW = normalized * halfW;
        ctx.fillStyle = 'rgba(80, 180, 80, 0.6)';
        ctx.fillRect(centerX, margin, fillW, gaugeH);
    }

    // Center line (zero)
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centerX, margin);
    ctx.lineTo(centerX, margin + gaugeH);
    ctx.stroke();

    // Border
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(margin, margin, gaugeW, gaugeH);

    // Label text
    ctx.fillStyle = '#333';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Decel', margin + 4, margin + 12);
    ctx.textAlign = 'right';
    ctx.fillText('Accel', w - margin - 4, margin + 12);

    // Show numeric value
    ctx.textAlign = 'center';
    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = (normalized >= 0) ? '#008000' : '#c00000';
    ctx.fillText(avgThrust.toFixed(0) + ' N', centerX, margin + gaugeH - 2);
}


// --- UPDATE & RENDER ---
function updatePhysicsState(dtOverride) {
    const dt = dtOverride || state.dt;
    state.t += dt;
    if(state.t > 1000) state.t = 0;

    const phys = calculatePhysics(state.t);
    
    // History (Decoupled from render frame rate)
    state.historyTimer += dt;
    
    while (state.historyTimer >= state.dt) {
        state.historyTimer -= state.dt;
        
        state.thrustHistory.push(phys.thrust);
        if (state.thrustHistory.length > 300) state.thrustHistory.shift();
        state.powerHistory.push(phys.power);
        if (state.powerHistory.length > 300) state.powerHistory.shift();
        
        // Avg Power
        const cyclePeriod = 1.0 / state.freq;
        const samplesPerCycle = cyclePeriod / state.dt;
        const windowSize = Math.ceil(samplesPerCycle * 4);
        const avgPowerWindow = state.powerHistory.slice(Math.max(0, state.powerHistory.length - windowSize));
        const avgPower = (avgPowerWindow.length > 0) ? (avgPowerWindow.reduce((a,b)=>a+b,0)/avgPowerWindow.length) : 0;
        state.avgPowerHistory.push(avgPower);
        if (state.avgPowerHistory.length > 300) state.avgPowerHistory.shift();

        // Avg Thrust
        const avgThrust = (state.thrustHistory.length > 0) ? (state.thrustHistory.reduce((a,b)=>a+b,0)/state.thrustHistory.length) : 0;
        state.avgThrustHistory.push(avgThrust);
        if (state.avgThrustHistory.length > 300) state.avgThrustHistory.shift();
    }
    
    // Get current averages for render
    const avgPower = state.avgPowerHistory.length > 0 ? state.avgPowerHistory[state.avgPowerHistory.length-1] : 0;
    const avgThrust = state.avgThrustHistory.length > 0 ? state.avgThrustHistory[state.avgThrustHistory.length-1] : 0;
    
    // Path
    state.pathX.push(phys.x);
    state.pathZ.push(phys.z);
    if (state.pathX.length > 300) { state.pathX.shift(); state.pathZ.shift(); }

    return { phys, avgPower, avgThrust };
}

function render(data) {
    const { phys, avgPower, avgThrust } = data;

    // UI
    ui.time.textContent = state.t.toFixed(2);
    ui.speed.textContent = (CONFIG.U * 3.6).toFixed(1);
    
    // Update New Angle Displays
    ui.pitch.textContent = (phys.theta * 180 / Math.PI).toFixed(1);
    ui.aoa.textContent = (phys.alpha * 180 / Math.PI).toFixed(1);

    ui.watts.textContent = phys.power.toFixed(0);
    ui.avgWatts.textContent = avgPower.toFixed(0);
    
    // Canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const PPU = 100;
    const camX = phys.x * PPU;
    const camOffset = canvas.width / 3;
    
    ctx.save();
    ctx.translate(-camX + camOffset, canvas.height * 0.70);
    
    // Environment
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 1;
    ctx.beginPath();
    const startGrid = Math.floor((phys.x - 2)); const endGrid = Math.floor((phys.x + 8));
    for (let i = startGrid; i <= endGrid; i++) { ctx.moveTo(i * PPU, -500); ctx.lineTo(i * PPU, 500); }
    ctx.moveTo(-10000, 0); ctx.lineTo(10000, 0); ctx.stroke();
    
    // Water Surface
    const surfaceZ = 0.85 / 2; 
    const surfaceY = -surfaceZ * PPU;
    ctx.fillStyle = 'rgba(0, 160, 255, 0.1)';
    ctx.fillRect(camX - 2000, surfaceY, 4000, 1000);
    ctx.beginPath(); ctx.moveTo(camX - 2000, surfaceY); ctx.lineTo(camX + 2000, surfaceY);
    ctx.strokeStyle = 'rgba(0, 160, 255, 0.5)'; ctx.lineWidth = 2; ctx.stroke();

    // Trail
    ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
    for(let i=0; i<state.pathX.length; i++){
        const px = state.pathX[i] * PPU; const pz = -state.pathZ[i] * PPU;
        if (i===0) ctx.moveTo(px, pz); else ctx.lineTo(px, pz);
    }
    ctx.stroke();
    
    const foilCX = phys.x * PPU; const foilCY = -phys.z * PPU;
    
    // Foil
    // Foil Assembly (Rigid Body)
    ctx.save(); ctx.translate(foilCX, foilCY); ctx.rotate(-phys.theta); 
    
    // Dimensions
    const mastH = 0.85 * PPU;
    const mastW = 0.06 * PPU;
    const fuseLen = 0.9 * PPU;
    const fuseRad = 0.015 * PPU;
    const mastX = -0.15 * PPU; 
    const boardL = 1.4 * PPU;
    const boardThick = 0.08 * PPU;

    if (VISIBILITY.assembly) {
        // 1. Mast & Fuselage & Stabilizer
        ctx.fillStyle = '#444';
        
        // Fuselage (extending backwards from wing)
        ctx.fillRect(-fuseLen + 0.1*PPU, -fuseRad, fuseLen, fuseRad*2);
        // Stabilizer (at the back)
        ctx.beginPath(); ctx.ellipse(-fuseLen + 0.15*PPU, 0, 0.12*PPU, 0.015*PPU, 0, 0, Math.PI*2); ctx.fill();
        // Mast (extending up)
        ctx.fillRect(mastX - mastW/2, -mastH, mastW, mastH);

        // 2. Board (on top of mast)
        ctx.fillStyle = '#ccc'; ctx.strokeStyle = '#999';
        ctx.beginPath(); ctx.rect(mastX - boardL/3, -mastH - boardThick, boardL, boardThick);
        ctx.fill(); ctx.stroke();
    }

    // 3. Stickman Rider
    if (VISIBILITY.rider && VISIBILITY.assembly) {
        const fatness = CONFIG.mass / 80.0;
        const limbWidth = 5 * fatness;
        const torsoWidth = 12 * fatness * fatness;

        ctx.strokeStyle = '#222'; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        const deckY = -mastH - boardThick;
        const legLen = 0.9 * PPU;
        const torsoLen = 0.55 * PPU;
        const headRad = 0.1 * PPU * Math.sqrt(fatness);
        
        // Crouch: z high (up) -> crouch=1 (bent). z low (down) -> crouch=0 (straight)
        const normZ = (state.heave_amp > 0.0001) ? Math.max(-1, Math.min(1, phys.z / state.heave_amp)) : 0;
        const crouch = (normZ + 1) / 2; 
        
        const curLegLen = legLen * (1.0 - 0.35 * crouch);
        
        // Feet positions (Fixed on board)
        const footRearX = mastX;
        const footFrontX = mastX + 0.4 * PPU;

        // Hip stabilized over front foot (World Up)
        const sinT = Math.sin(phys.theta);
        const cosT = Math.cos(phys.theta);
        
        const hipX = footFrontX + curLegLen * sinT;
        const hipY = deckY - curLegLen * cosT;
        
        const kneeBend = 0.25 * PPU * crouch;

        // Legs
        ctx.lineWidth = limbWidth;
        ctx.beginPath(); ctx.moveTo(footRearX, deckY); ctx.quadraticCurveTo(footRearX + (hipX - footRearX)/2 + kneeBend, deckY - curLegLen/2, hipX, hipY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(footFrontX, deckY); ctx.quadraticCurveTo(footFrontX + (hipX - footFrontX)/2 + kneeBend, deckY - curLegLen/2, hipX, hipY); ctx.stroke();
        
        // Torso & Head (Upright in World Space)
        const shoulderX = hipX + torsoLen * sinT;
        const shoulderY = hipY - torsoLen * cosT;

        ctx.lineWidth = torsoWidth;
        ctx.beginPath(); ctx.moveTo(hipX, hipY); ctx.lineTo(shoulderX, shoulderY); ctx.stroke();
        ctx.beginPath(); ctx.fillStyle='#eee'; ctx.lineWidth=2; ctx.arc(shoulderX, shoulderY - headRad, headRad, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        
        // Arms
        const armDx = 0.45 * PPU;
        const armDy = 0.15 * PPU;
        const rArmX = shoulderX + (armDx * cosT - armDy * sinT);
        const rArmY = shoulderY + (armDx * sinT + armDy * cosT);
        const lArmX = shoulderX - (armDx * cosT + armDy * sinT);
        const lArmY = shoulderY + (-armDx * sinT + armDy * cosT);

        ctx.lineWidth = limbWidth;
        ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(rArmX, rArmY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(lArmX, lArmY); ctx.stroke();
    }

    // 3. Main Wing (NACA Profile) - Centered at (0,0)
    const chordPx = CONFIG.visual_size_m * PPU;
    const toLocalX = (nx) => (0.25 - nx) * chordPx; 
    ctx.beginPath(); ctx.fillStyle = 'black';
    ctx.moveTo(toLocalX(foilShape[0].x), -foilShape[0].y * chordPx);
    for (let i = 1; i < foilShape.length; i++) ctx.lineTo(toLocalX(foilShape[i].x), -foilShape[i].y * chordPx);
    for (let i = foilShape.length - 1; i >= 0; i--) ctx.lineTo(toLocalX(foilShape[i].x), foilShape[i].y * chordPx);
    ctx.fill(); ctx.restore();

    // Vectors
    const vecScale = 0.2; 
    if (VISIBILITY.lift) drawArrow(ctx, foilCX, foilCY, phys.Lx, phys.Lz, 'blue', vecScale, CONFIG.scale_L);
    if (VISIBILITY.drag) drawArrow(ctx, foilCX, foilCY, phys.Dx, phys.Dz, 'red', vecScale, CONFIG.scale_D);
    if (VISIBILITY.rider) drawArrow(ctx, foilCX, foilCY, phys.Rx, phys.Rz, 'orange', vecScale, CONFIG.scale_R);
    if (VISIBILITY.net) drawArrow(ctx, foilCX, foilCY, phys.Nx, phys.Nz, 'green', vecScale, CONFIG.scale_N);
    if (VISIBILITY.thrust) drawArrow(ctx, foilCX, foilCY, phys.thrust, 0, 'cyan', vecScale, CONFIG.scale_T);

    ctx.restore();
    
    // Graphs
    drawSimpleGraph(ctxThrust, state.thrustHistory, "NET THRUST (N)", "rgba(0,128,0,0.35)", "rgba(255,0,0,0.28)");
    drawSimpleGraph(ctxPower, state.powerHistory, "RIDER INSTANTANEOUS POWER (Watts)", "rgba(255,165,0,0.4)", null);
    drawSimpleGraph(ctxAvgPower, state.avgPowerHistory, "RIDER AVG POWER (Watts)", "rgba(255,140,0,0.5)", null);

    // Update avg thrust status bar
    ui.avgThrust.textContent = avgThrust.toFixed(0);
    const statusEl = document.getElementById('avgThrustStatus');
    if (avgThrust >= 0) {
        statusEl.style.backgroundColor = '#c8e6c9';
        statusEl.style.color = '#1b5e20';
        statusEl.textContent = 'Avg Thrust: Accelerating : ' + avgThrust.toFixed(0) + ' N';
    } else {
        statusEl.style.backgroundColor = '#ffcdd2';
        statusEl.style.color = '#b71c1c';
        statusEl.textContent = 'Avg Thrust: Decelerating : ' + avgThrust.toFixed(0) + ' N';
    }
}

// --- LISTENERS ---
document.getElementById('in-freq').addEventListener('input', (e) => { state.freq = parseFloat(e.target.value); ui.dispFreq.textContent = state.freq.toFixed(2); });
document.getElementById('in-amp').addEventListener('input', (e) => { state.heave_amp = parseFloat(e.target.value); ui.dispAmp.textContent = state.heave_amp.toFixed(2); });
document.getElementById('in-size').addEventListener('input', (e) => { CONFIG.visual_size_m = parseFloat(e.target.value); ui.dispSize.textContent = CONFIG.visual_size_m.toFixed(2); });
document.getElementById('in-speed').addEventListener('input', (e) => { const kph = parseFloat(e.target.value); CONFIG.U = kph / 3.6; ui.dispSpeed.textContent = kph.toFixed(1); });
document.getElementById('in-mass').addEventListener('input', (e) => { CONFIG.mass = parseFloat(e.target.value); ui.dispMass.textContent = CONFIG.mass.toFixed(0); });
document.getElementById('in-area').addEventListener('input', (e) => { const cm2 = parseFloat(e.target.value); CONFIG.S = cm2 / 10000; ui.dispArea.textContent = cm2.toFixed(0); });
document.getElementById('in-ar').addEventListener('input', (e) => { CONFIG.AR = parseFloat(e.target.value); ui.dispAr.textContent = CONFIG.AR.toFixed(1); });
document.getElementById('in-cd0').addEventListener('input', (e) => { CONFIG.Cd0 = parseFloat(e.target.value); ui.dispCd0.textContent = CONFIG.Cd0.toFixed(3); });
document.getElementById('in-trim').addEventListener('input', (e) => { CONFIG.pitch_trim_deg = parseFloat(e.target.value); ui.dispTrim.textContent = CONFIG.pitch_trim_deg.toFixed(1); });
document.getElementById('in-phase').addEventListener('input', (e) => { CONFIG.phase_shift_deg = parseFloat(e.target.value); ui.dispPhase.textContent = CONFIG.phase_shift_deg.toFixed(0); });
document.getElementById('chk-slowmo').addEventListener('change', (e) => { state.slowMotion = e.target.checked; });

document.getElementById('btn-reset').addEventListener('click', () => {
    state.freq = 0.8; document.getElementById('in-freq').value = 0.8; ui.dispFreq.textContent = "0.8";
    state.heave_amp = 0.22; document.getElementById('in-amp').value = 0.22; ui.dispAmp.textContent = "0.22";
    CONFIG.U = 15.0 / 3.6; document.getElementById('in-speed').value = 15.0; ui.dispSpeed.textContent = "15.0";
    CONFIG.mass = 80.0; document.getElementById('in-mass').value = 80; ui.dispMass.textContent = "80";
    CONFIG.S = 0.15; document.getElementById('in-area').value = 1500; ui.dispArea.textContent = "1500";
    CONFIG.AR = 13.0; document.getElementById('in-ar').value = 13.0; ui.dispAr.textContent = "13.0";
    CONFIG.Cd0 = 0.02; document.getElementById('in-cd0').value = 0.02; ui.dispCd0.textContent = "0.020";
    CONFIG.pitch_trim_deg = 1.0; document.getElementById('in-trim').value = 1.0; ui.dispTrim.textContent = "1.0";
    CONFIG.phase_shift_deg = 90.0; document.getElementById('in-phase').value = 90; ui.dispPhase.textContent = "90";
    CONFIG.visual_size_m = 0.4; document.getElementById('in-size').value = 0.4; ui.dispSize.textContent = "0.40";
    state.slowMotion = false; document.getElementById('chk-slowmo').checked = false;
    
    // Clear history for clean restart
    state.thrustHistory = []; state.powerHistory = []; state.avgPowerHistory = []; state.avgThrustHistory = [];
});

document.getElementById('chk-lift').addEventListener('change', (e) => VISIBILITY.lift = e.target.checked);
document.getElementById('chk-drag').addEventListener('change', (e) => VISIBILITY.drag = e.target.checked);
document.getElementById('chk-rider').addEventListener('change', (e) => VISIBILITY.rider = e.target.checked);
document.getElementById('chk-net').addEventListener('change', (e) => VISIBILITY.net = e.target.checked);
document.getElementById('chk-thrust').addEventListener('change', (e) => VISIBILITY.thrust = e.target.checked);
document.getElementById('chk-assembly').addEventListener('change', (e) => VISIBILITY.assembly = e.target.checked);

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') state.paused = !state.paused;
    if (state.paused) {
        if (e.code === 'ArrowRight') render(updatePhysicsState());
        if (e.code === 'ArrowLeft') {
            state.t -= state.dt;
            render({ 
                phys: calculatePhysics(state.t), 
                avgPower: state.avgPowerHistory[state.avgPowerHistory.length-1] || 0, 
                avgThrust: state.avgThrustHistory[state.avgThrustHistory.length-1] || 0 
            });
        }
    }
});

function loop() {
    if (!state.paused) {
        let data;
        // Normal: 2 steps of 0.01s = 0.02s/frame
        // SlowMo: 1 step of 0.002s = 0.002s/frame (1/10th speed) or 0.004s (1/5th)
        const steps = state.slowMotion ? 1 : 2;
        const dtStep = state.slowMotion ? 0.004 : 0.01;
        
        for(let i=0; i<steps; i++) data = updatePhysicsState(dtStep);
        render(data);
    }
    requestAnimationFrame(loop);
}

render({ phys: calculatePhysics(0), avgPower: 0, avgThrust: 0 });
loop();

</script>
</body>
</html>