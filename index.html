<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1024, user-scalable=yes">
    <title>Pump Foil Simulator (Angle Telemetry)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
            background-color: #f4f4f5;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            overflow: auto;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            max-width: 900px;
            min-width: 900px;
        }

        .canvas-wrapper {
            position: relative;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.05);
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
            width: 100%;
            height: auto;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            pointer-events: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            min-width: 260px;
            z-index: 10;
        }

        #controls {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 300px;
            box-sizing: border-box;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 110px;
        }

        label {
            font-size: 10px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
        }

        input[type=range] {
            height: 4px;
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 6px 0;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .dot { width: 8px; height: 8px; border-radius: 50%; }
        input[type=checkbox] { cursor: pointer; }
        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            padding: 2px 4px;
            font-size: 9px;
            font-weight: 700;
        }

        #dashboard-row {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            gap: 10px;
            width: 100%;
        }
        #graphs-column {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        /* Make graphs fill the available height to align with controls */
        #graphs-column .canvas-wrapper:not(#avgThrustStatus):not(#avgLiftStatus) {
            display: flex;
            flex-direction: column;
        }
        #graphs-column .canvas-wrapper:not(#avgThrustStatus):not(#avgLiftStatus) canvas {
            width: 100%;
            height: auto;
        }

        @media (max-width: 768px) {
            #ui-overlay {
                font-size: 11px;
                padding: 10px;
                min-width: 140px;
                right: 10px;
                top: 10px;
            }
        }

        /* Custom Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #888;
        }
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px 10px;
            position: absolute;
            z-index: 100;
            top: 50%;
            right: 105%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.1s;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 11px;
            line-height: 1.4;
            font-weight: normal;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none;
        }
        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 100%;
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent transparent #333;
        }
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        #slowmo-controls {
            position: absolute;
            bottom: 15px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.90);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
            font-size: 11px;
            font-weight: bold;
            color: #555;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }

        #visibility-controls {
            position: absolute;
            bottom: 15px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.90);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            display: grid;
            grid-template-columns: repeat(4, auto);
            gap: 4px 12px;
            font-size: 10px;
            font-weight: bold;
            color: #555;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
        }
        .legend-item { display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none; }

        @media (max-width: 768px) {
            #visibility-controls {
                grid-template-columns: repeat(3, auto);
                right: 10px;
            }
        }

        /* Documentation Dropdown */
        details {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0,0,0,0.05);
            overflow: hidden;
            width: 100%;
            margin-top: 15px;
            box-sizing: border-box;
        }
        summary {
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            background-color: #fff;
            font-size: 14px;
            color: #333;
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        summary::-webkit-details-marker {
            display: none;
        }
        summary::after {
            content: '+';
            font-size: 18px;
            font-weight: bold;
            color: #666;
        }
        details[open] summary::after {
            content: '-';
        }
        details[open] summary {
            border-bottom: 1px solid #eee;
        }
        .readme-content {
            padding: 20px;
            font-size: 13px;
            line-height: 1.6;
            color: #444;
        }
        .readme-content h1 { font-size: 18px; margin-top: 0; margin-bottom: 10px; color: #222; }
        .readme-content h2 { font-size: 16px; margin-top: 15px; margin-bottom: 10px; color: #333; }
        .readme-content p { margin-bottom: 10px; }
        .readme-content ul { margin-bottom: 10px; padding-left: 20px; }
        .readme-content li { margin-bottom: 4px; }
        .readme-content a { color: #3b82f6; text-decoration: none; }
        .readme-content a:hover { text-decoration: underline; }
    </style>
</head>
<body>

    <div id="main-container">
        <div class="canvas-wrapper">
            <canvas id="simCanvas" width="900" height="380"></canvas>
            <div id="ui-overlay">
                <strong>Live Telemetry</strong><br>
                Time: <span id="val-time">0.00</span> s<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Pitch (vs Horizon): <span id="val-pitch">0.0</span>Â°<br>
                <span class="tooltip">AoA (vs Water flow)
                    <span class="tooltip-text">
                        The angle of the wing relative to the oncoming water flow (not the horizon).<br>
                        â€¢ Positive AoA generates Lift.<br>
                        â€¢ Too high (>12Â°) causes Drag and Stalling.<br>
                        â€¢ In a pump, plunging down increases your AoA, while rising up decreases it.
                    </span>
                </span>: <span id="val-aoa">0.0</span>Â°<br>
                <hr style="border: 0; border-top: 1px solid #ddd; margin: 4px 0;">
                Instantaneous Power: <span id="val-watts">0</span> W<br>
                Average Power: <span id="val-arith-avg-watts">0</span> W<br>
                Normalized Power: <span id="val-avg-watts">0</span> W
            </div>
            <div id="slowmo-controls">
                <div style="display: flex; align-items: center; gap: 6px;">
                    <input type="checkbox" id="chk-slowmo" style="cursor: pointer;">
                    <label for="chk-slowmo" style="cursor: pointer; user-select: none;">Slow Motion</label>
                </div>
                <div style="font-size: 9px; color: #555; font-weight: normal; display: flex; gap: 10px;">
                    <span id="cmd-pause" style="cursor: pointer; user-select: none;" title="Toggle Pause"><kbd>SPACE</kbd> Pause</span>
                    <span id="cmd-rewind" style="cursor: pointer; user-select: none;" title="Step Back"><kbd>&larr;</kbd> Rewind</span>
                    <span id="cmd-forward" style="cursor: pointer; user-select: none;" title="Step Forward"><kbd>&rarr;</kbd> Forward</span>
                </div>
            </div>
            <div id="visibility-controls">
                <label class="legend-item"><input type="checkbox" id="chk-lift" checked><div class="dot" style="background: blue;"></div> Lift</label>
                <label class="legend-item"><input type="checkbox" id="chk-drag" checked><div class="dot" style="background: red;"></div> Drag</label>
                <label class="legend-item"><input type="checkbox" id="chk-rider" checked><div class="dot" style="background: orange;"></div> Rider</label>
                <label class="legend-item"><input type="checkbox" id="chk-thrust" checked><div class="dot" style="background: cyan; border:1px solid #999;"></div> Thrust</label>
                <label class="legend-item"><input type="checkbox" id="chk-weight"><div class="dot" style="background: rgb(255, 251, 0);"></div> G-Force</label>
                <label class="legend-item"><input type="checkbox" id="chk-assembly" checked><div class="dot" style="background: #666;"></div> Board+Rider</label>
                <label class="legend-item"><input type="checkbox" id="chk-stab" checked><div class="dot" style="background: #d946ef;"></div> Stabilizer</label>
                <label class="legend-item"><input type="checkbox" id="chk-net"><div class="dot" style="background: lime; border:1px solid #333;"></div> Net Force</label>
                <label class="legend-item" title="Toggle between accurate 1:1 scaling and exaggerated scaling for small forces"><input type="checkbox" id="chk-true-scale" checked> True Scale</label>
            </div>
        </div>

        <div id="dashboard-row">
            <div id="graphs-column">
                <div class="canvas-wrapper">
                    <canvas id="graphLift" width="1300" height="260"></canvas>
                </div>
                <div class="canvas-wrapper" id="avgLiftStatus" style="padding: 8px; text-align: center; font-size: 12px; font-weight: bold; background-color: #e8f5e9;">
                    Avg Lift: Balanced : <span id="val-avg-lift">0</span> N
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphThrust" width="1300" height="260"></canvas>
                </div>
                <div class="canvas-wrapper" id="avgThrustStatus" style="padding: 8px; text-align: center; font-size: 12px; font-weight: bold; background-color: #e8f5e9;">
                    Avg Thrust: Accelerating : <span id="val-avg-thrust">0</span> N
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphGForce" width="1300" height="260"></canvas>
                </div>
                <div class="canvas-wrapper" id="avgGForceStatus" style="padding: 8px; text-align: center; font-size: 12px; font-weight: bold; background-color: #f3e5f5;">
                    Avg Rider G-Force: <span id="val-avg-gforce">0</span> G
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphPower" width="1300" height="260"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphAvgPower" width="1300" height="260"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="graphPowerComp" width="1300" height="260"></canvas>
                </div>

                <!-- GROUP: PRESETS (Moved) -->
                <div style="background-color: #fff7ed; padding: 8px; border-radius: 6px; border: 1px solid #ffedd5; display: flex; flex-direction: column; gap: 8px;">
                    <div class="control-group" title="Save and load configurations.">
                        <label>Presets</label>
                        <div style="display:flex; gap:5px;">
                            <select id="preset-select" style="flex:1; font-size:11px; padding:4px; border-radius:4px; border:1px solid #ccc;">
                                <option value="">-- Select --</option>
                            </select>
                        </div>
                        <div style="display:flex; gap:5px; margin-top:4px;">
                            <button id="btn-save-preset" style="flex:1; cursor:pointer; font-size:10px; padding:4px; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#d97706;">SAVE</button>
                            <button id="btn-delete-preset" style="flex:1; cursor:pointer; font-size:10px; padding:4px; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#dc2626;">DELETE</button>
                            <button id="btn-download-preset" style="flex:1; cursor:pointer; font-size:10px; padding:4px; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#2563eb;">DOWNLOAD</button>
                            <button id="btn-upload-preset" style="flex:1; cursor:pointer; font-size:10px; padding:4px; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#059669;">UPLOAD</button>
                            <button id="btn-reset-presets" style="flex:1; cursor:pointer; font-size:10px; padding:4px; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#4b5563;" title="Restore default presets">RESET</button>
                        </div>
                        <input type="file" id="file-upload-preset" style="display:none" accept=".json">
                    </div>
                </div>
            </div>
            
            <div id="controls">
            <!-- GROUP 1: SPEED -->
            <div style="background-color: #f0f9ff; padding: 8px; border-radius: 6px; border: 1px solid #bae6fd; display: flex; flex-direction: column; gap: 8px;">
                <div class="control-group" title="Forward velocity of the rider.">
                    <label>Speed: <span id="disp-speed">20.0</span> km/h</label>
                    <input type="range" id="in-speed" min="10.0" max="30.0" step="1.0" value="20.0">
                </div>
            </div>

            <!-- GROUP 2: KINEMATICS -->
            <div style="background-color: #f8fafc; padding: 8px; border-radius: 6px; border: 1px solid #e2e8f0; display: flex; flex-direction: column; gap: 8px;">
                <div class="control-group" title="Pumping cadence in cycles per second (Hz).">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label>Frequency: <span id="disp-freq">1.65</span> Hz <span style="font-weight:normal; color:#666;">(<span id="disp-ppm">99</span> ppm)</span></label>
                        <label style="font-size:9px; cursor:pointer; color:#666; font-weight:bold;"><input type="checkbox" id="lock-freq" style="margin:0 3px 0 0; vertical-align:middle;"> LOCK</label>
                    </div>
                    <input type="range" id="in-freq" min="0.01" max="2.5" step="0.01" value="1.65">
                </div>
                <div class="control-group" title="Vertical range of motion for the foil path.">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label>Amplitude: <span id="disp-amp">0.13</span> m</label>
                        <label style="font-size:9px; cursor:pointer; color:#666; font-weight:bold;"><input type="checkbox" id="lock-amp" style="margin:0 3px 0 0; vertical-align:middle;"> LOCK</label>
                    </div>
                    <input type="range" id="in-amp" min="0.00" max="0.30" step="0.01" value="0.13">
                </div>
                <div class="control-group" title="Controls the timing asymmetry. Positive values create a Quick Down / Slow Up rhythm.">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label>Asymmetry: <span id="disp-asym">0.00</span></label>
                        <label style="font-size:9px; cursor:pointer; color:#666; font-weight:bold;"><input type="checkbox" id="lock-asym" style="margin:0 3px 0 0; vertical-align:middle;"> LOCK</label>
                    </div>
                    <input type="range" id="in-asym" min="0.0" max="0.8" step="0.01" value="0.0">
                </div>
                <div class="control-group" title="Base pitch angle of the front wing relative to the fuselage.">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label>Front Wing Pitch: <span id="disp-trim">3.3</span>Â°</label>
                        <label style="font-size:9px; cursor:pointer; color:#666; font-weight:bold;"><input type="checkbox" id="lock-trim" style="margin:0 3px 0 0; vertical-align:middle;"> LOCK</label>
                    </div>
                    <input type="range" id="in-trim" min="-2.0" max="10.0" step="0.1" value="3.3">
                </div>
                <div class="control-group" title="Timing difference between heave and pitch. 90Â° is ideal (Pitch follows Velocity). Range: 80Â°-110Â°.">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label>Phase Shift: <span id="disp-phase">90</span>Â°</label>
                        <label style="font-size:9px; cursor:pointer; color:#666; font-weight:bold;"><input type="checkbox" id="lock-phase" style="margin:0 3px 0 0; vertical-align:middle;" checked> LOCK</label>
                    </div>
                    <input type="range" id="in-phase" min="80" max="110" step="1" value="90">
                </div>
                <div class="control-group" title="Average distance from the water surface to the wing. Lower = Less Drag but Risk of Breach.">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label>Ride Height: <span id="disp-height">0.20</span> m</label>
                        <label style="font-size:9px; cursor:pointer; color:#666; font-weight:bold;"><input type="checkbox" id="lock-height" style="margin:0 3px 0 0; vertical-align:middle;" checked> LOCK</label>
                    </div>
                    <input type="range" id="in-height" min="0.10" max="0.80" step="0.01" value="0.20">
                </div>
            </div>

            <button id="btn-optimize" style="width:100%; padding: 8px; margin-top: 5px; cursor: pointer; font-size: 11px; font-weight: bold; background: #f0fdf4; border: 1px solid #86efac; border-radius: 6px; color: #166534; transition: background 0.2s;">ðŸŽ¯ FIND SETTINGS MAGICALLY</button>

            <!-- GROUP 3: CONFIGURATION -->
            <div style="background-color: #fdf4ff; padding: 8px; border-radius: 6px; border: 1px solid #f0abfc; display: flex; flex-direction: column; gap: 8px;">
                <div class="control-group" title="Total weight of rider plus gear.">
                    <label>Mass: <span id="disp-mass">70</span> kg</label>
                    <input type="range" id="in-mass" min="40" max="120" step="1" value="70">
                </div>
                <div class="control-group" title="Surface area of the front wing. Larger wings lift more but drag more.">
                    <label>Wing Area: <span id="disp-area">1350</span> cmÂ²</label>
                    <input type="range" id="in-area" min="600" max="2000" step="50" value="1350">
                </div>
                <div class="control-group" title="Ratio of span to chord. High AR is more efficient (glides better).">
                    <label>Wing AR: <span id="disp-ar">13.9</span></label>
                    <input type="range" id="in-ar" min="5.0" max="20.0" step="0.1" value="13.9">
                </div>
                <div class="control-group" title="Parasitic drag. Lower is more hydrodynamic (thinner mast/wing).">
                    <label>Drag Coeff (Cd0): <span id="disp-cd0">0.013</span></label>
                    <input type="range" id="in-cd0" min="0.010" max="0.035" step="0.001" value="0.013">
                </div>
                <div class="control-group" title="Surface area of the stabilizer.">
                    <label>Stab Area: <span id="disp-stab-area">120</span> cmÂ²</label>
                    <input type="range" id="in-stab-area" min="0" max="500" step="10" value="120">
                </div>
                <div class="control-group" title="Aspect Ratio of the stabilizer. Higher = More Damping (Harder to pump).">
                    <label>Stab AR: <span id="disp-stab-ar">8.0</span></label>
                    <input type="range" id="in-stab-ar" min="6.0" max="20.0" step="0.1" value="8.0">
                </div>
                <div class="control-group" title="Angle of the rear stabilizer. Negative values create downforce (stability).">
                    <label>Stab Angle: <span id="disp-stab-angle">-1.0</span>Â°</label>
                    <input type="range" id="in-stab-angle" min="-3.0" max="3.0" step="0.1" value="-1.0">
                </div>
                <div class="control-group" title="Distance from the mast/front wing to the stabilizer.">
                    <label>Fuselage Length: <span id="disp-fuse-len">0.60</span> m</label>
                    <input type="range" id="in-fuse-len" min="0.10" max="1.00" step="0.01" value="0.60">
                </div>
                <div class="control-group" title="Where the rider stands relative to the Front Wing Lift. Positive = Forward (Nose Down).">
                    <label>Rider Offset: <span id="disp-offset">0.00</span> m</label>
                    <input type="range" id="in-offset" min="-0.20" max="0.30" step="0.01" value="0.0">
                </div>
            </div>

            <!-- GROUP 4: SIMULATION -->
            <div style="background-color: #f4f4f5; padding: 8px; border-radius: 6px; border: 1px solid #e4e4e7; display: flex; flex-direction: column; gap: 8px;">
                <div class="control-group" title="Percentage of body mass that moves with the board up and down.">
                    <label>Swing Weight: <span id="disp-swing">40</span>%</label>
                    <input type="range" id="in-swing" min="0.1" max="0.65" step="0.05" value="0.4">
                </div>
                <div class="control-group" title="Percentage of energy from system elasticity, helping to pump more efficiently.">
                    <label>System Elasticity: <span id="disp-elastic">0</span>%</label>
                    <input type="range" id="in-elastic" min="0" max="30" step="1" value="0">
                </div>
                <div class="control-group" title="Zoom level for the foil visualization.">
                    <label>Visualization Scale: <span id="disp-size">0.40</span></label>
                    <input type="range" id="in-size" min="0.10" max="1.0" step="0.05" value="0.4">
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 5px;">
                <button id="btn-reset" style="flex: 1; padding: 8px; cursor: pointer; font-size: 11px; font-weight: bold; background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 6px; color: #475569; transition: background 0.2s;">RESET</button>
                <button id="btn-replay" style="flex: 1; padding: 8px; cursor: pointer; font-size: 11px; font-weight: bold; background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 6px; color: #475569; transition: background 0.2s;">REPLAY</button>
                <button id="btn-tests" style="flex: 1; padding: 8px; cursor: pointer; font-size: 11px; font-weight: bold; background: #e0f2fe; border: 1px solid #7dd3fc; border-radius: 6px; color: #0369a1; transition: background 0.2s;" title="Run Validation Suite (Check Console)">TESTS</button>
            </div>

        </div> <!-- End controls -->
        </div> <!-- End dashboard-row -->

        <details id="readme-dropdown">
            <summary>Documentation & About</summary>
            <div class="readme-content">
                <h2>Physics Model</h2>
                <p>The simulation uses a custom quasi-steady solver that iterates through time steps (<i>dt</i>) to calculate forces and rider power.</p>

                <h3>Simplifications</h3>
                <ul>
                    <li>Forces are calculated for the front wing, rear stabilizer, and mast</li>
                    <li>The indication bars for average lift and thrust indicate whether the pumping motion is actually viable for the selected speed. If they're not balanced / on target, the selected parameters are not in steady state.</li>
                    <li>The stickfigure is only there for your entertainment - the trajectory of the foil is defined by the frequency and amplitude input.</li>
                </ul>

                <h3>1. Kinematics (Motion)</h3>
                <p>The rider's vertical motion (<strong>Heave</strong>) and the board's angle (<strong>Pitch</strong>) are driven by sinusoidal functions, linked by a configurable <strong>Phase Shift</strong>.</p>

                <ul>
                    <li><strong>Frequency:</strong> <i>&omega; = 2&pi;f</i></li>
                    <li><strong>Vertical Position (<i>z</i>):</strong> <i>z(t) = A cos(&omega;t)</i></li>
                    <li><strong>Vertical Velocity (<i>v<sub>z</sub></i>):</strong> <i>v<sub>z</sub>(t) = -A &omega; sin(&omega;t)</i></li>
                    <li><strong>Vertical Acceleration (<i>a<sub>z</sub></i>):</strong> <i>a<sub>z</sub>(t) = -A &omega;<sup>2</sup> cos(&omega;t)</i></li>
                    <li><strong>Pitch Angle (<i>&theta;</i>):</strong> <i>&theta;(t) = &theta;<sub>trim</sub> + &theta;<sub>amp</sub> cos(&omega;t + &phi;)</i><br>
                    <em>(Where &phi; is the Phase Shift)</em></li>
                    <li><strong>Physical Execution:</strong> The rider achieves this by shifting their weight (Center of Pressure) forward or backward relative to their vertical extension. A 90&deg; shift means pitching the nose down exactly when moving fastest downwards. A higher shift (&gt;90&deg;) means initiating the pitch change <em>early</em> (leading the motion).</li>
                    <li><strong>Standard Phase:</strong> <i>&phi; = &omega;t</i></li>
                    <li><strong>Asymmetric Phase:</strong> <i>&phi;<sub>asym</sub> = &phi; - Asymmetry cos(&phi;)</i></li>
                    <li><strong>Vertical Position (<i>z</i>):</strong> <i>z(t) = A cos(&phi;<sub>asym</sub>)</i></li>
                    <li><strong>Vertical Velocity (<i>v<sub>z</sub></i>):</strong> <i>v<sub>z</sub>(t) = -A sin(&phi;<sub>asym</sub>) d&phi;<sub>asym</sub>/dt</i></li>
                    <li><strong>Vertical Acceleration (<i>a<sub>z</sub></i>):</strong> Calculated as the derivative of <i>v<sub>z</sub></i>.</li>
                    <li><strong>Pitch Angle (<i>&theta;</i>):</strong> <i>&theta;(t) = &theta;<sub>trim</sub> + &theta;<sub>amp</sub> cos(&phi;<sub>asym</sub> + &phi;<sub>shift</sub>)</i></li>
                </ul>

                <h3>2. Fluid Forces</h3>
                <p>Lift and Drag are calculated using <strong>Thin Airfoil Theory</strong>, corrected for a finite Aspect Ratio (<i>AR</i>).</p>

                <ul>
                    <li><strong>Flight Path Angle (<i>&gamma;</i>):</strong> <i>&gamma; = arctan(v<sub>z</sub> / U)</i></li>
                    <li><strong>Effective Angle of Attack (<i>&alpha;</i>):</strong> <i>&alpha; = &theta; - &gamma;</i></li>
                    <li><strong>Lift Coefficient (<i>C<sub>L</sub></i>):</strong><br>
                    <i>C<sub>L</sub> = (2 &pi; &alpha;) / (1 + 2/AR)</i></li>
                    <li><strong>Drag Coefficient (<i>C<sub>D</sub></i>):</strong><br>
                    <i>C<sub>D</sub> = C<sub>D0</sub> + k C<sub>L</sub><sup>2</sup></i> &emsp; where &emsp; <i>k &approx; 1 / (&pi; AR)</i></li>
                    <li><strong>Total Hydrodynamic Force (Vertical):</strong><br>
                    <i>F<sub>hydro_z</sub> = F<sub>wing_z</sub> + F<sub>stab_z</sub> + F<sub>mast_z</sub></i> (Sum of all vertical forces).</li>
                    <li><strong>Stall Model:</strong><br>
                    Beyond a critical angle (~13&deg;), the lift coefficient saturates and drag increases significantly to simulate stalling.</li>
                </ul>

                <h3>2b. Mast Drag & Ventilation</h3>
                <p>To increase realism, the simulation accounts for the mast's drag and surface effects.</p>
                <ul>
                    <li><strong>Mast Drag:</strong> Calculated based on the submerged length of the mast at each time step.</li>
                    <li><strong>Ventilation:</strong> If the wing approaches or breaches the surface (<i>z &gt; 0</i>), the lift coefficient is penalized to simulate air entrainment (ventilation), preventing the rider from generating power above the water.</li>
                </ul>

                <h3>3. Dynamics (Two-Mass Model)</h3>
                <p>To simulate high-frequency pumping accurately, the system is split into a <strong>Fixed Mass</strong> (Torso) and a <strong>Moving Mass</strong> (Legs + Board). This prevents the "zero power" error seen in single-point mass models when acceleration exceeds gravity.</p>

                <ul>
                    <li><strong>Moving Mass (<i>m<sub>moving</sub></i>):</strong><br>
                    <i>m<sub>moving</sub> = m<sub>board</sub> + (m<sub>rider</sub> &times; SwingRatio)</i><br>
                    <em>(Default SwingRatio is 0.4. Can exceed 0.5 for aggressive pumping involving hips/torso)</em></li>
                    <li><strong>Inertial Requirement:</strong><br>
                    The force required to accelerate the legs and board:<br>
                    <i>F<sub>inertia</sub> = m<sub>moving</sub> (g + a<sub>z</sub>)</i></li>
                    <li><strong>Hydrodynamic Added Mass:</strong><br>
                    Accelerating the wing moves a volume of water with it. This "virtual mass" is added to the inertial requirement. It is scaled by <i>cos<sup>2</sup>(&theta;)</i> because added mass acts perpendicular to the wing surface.<br>
                    <i>m<sub>added</sub> = &rho; &pi; (c/2)<sup>2</sup> b cos<sup>2</sup>(&theta;)</i></li>
                    <li><strong>Rider Force (<i>F<sub>rider</sub></i>):</strong><br>
                    The rider must push down to bridge the gap between the Water Force and the Inertial Force.<br>
                    <i>F<sub>req</sub> = F<sub>hydro_z</sub> - F<sub>inertia</sub> - m<sub>added</sub> a<sub>z</sub></i><br>
                    <i>F<sub>rider</sub> = max(0, F<sub>req</sub>)</i><br>
                    <em>(Clamped to 0 to simulate unstrapped ridingâ€”the rider cannot pull the board up).</em></li>
                </ul>

                <h3>3b. Stabilizer & Pitching Moment</h3>
                <p>The simulation now includes a rear stabilizer and calculates the torque (Pitching Moment) the rider must manage.</p>
                <ul>
                    <li><strong>Stabilizer Aerodynamics:</strong><br>
                    Calculates local Angle of Attack based on the <strong>Local Velocity Vector</strong> at the tail (<i>v<sub>z_stab</sub> = v<sub>z</sub> - &omega;<sub>pitch</sub> &times; FuselageLength</i>). This accounts for <strong>Downwash</strong> and naturally provides <strong>Pitch Damping</strong> without artificial terms.</li>
                    <li><strong>Moment Summation (at Center of Lift):</strong><br>
                    <ul>
                        <li><strong>Stabilizer Moment:</strong> <i>M<sub>stab</sub> = -L<sub>stab</sub> &times; FuselageLength</i></li>
                        <li><strong>Rider Offset Moment:</strong> Torque created if the rider stands forward or aft of the Center of Lift.</li>
                        <li><strong>Total Moment:</strong> <i>M<sub>total</sub> = M<sub>stab</sub> + M<sub>rider</sub></i></li>
                    </ul></li>
                </ul>

                <h3>4. Power Calculation</h3>
                <p>Power is the sum of Linear Power (legs pushing down) and Rotational Power (core/ankles fighting torque).</p>

                <ul>
                    <li><strong>Linear Power:</strong><br>
                    <i>P<sub>linear</sub> = max(0, F<sub>rider</sub> &times; v<sub>ext</sub>)</i></li>
                    <li><strong>Rotational Power:</strong><br>
                    <i>P<sub>rot</sub> = |M<sub>total</sub> &times; &omega;<sub>pitch</sub>|</i><br>
                    <em>(Absolute value is used because muscles consume energy to resist torque even during eccentric loading).</em></li>
                    <li><strong>Total Power:</strong> <i>P<sub>total</sub> = P<sub>linear</sub> + P<sub>rot</sub></i></li>
                </ul>

                <h3>5. Power Metrics (Normalized vs Average)</h3>
                <ul>
                    <li><strong>Average Power:</strong><br>
                    The arithmetic mean of the power output. It represents the total physical work done over time.</li>
                    <li><strong>Normalized Power:</strong><br>
                    A weighted average that emphasizes high-intensity spikes. Since physiological fatigue increases non-linearly with intensity, this metric better represents the metabolic "cost" of the session. It is calculated using a 4th-power weighting algorithm:<br>
                    <i>P<sub>norm</sub> = ( &Sigma; P<sup>4</sup> / N )<sup>0.25</sup></i></li>
                </ul>

                <h2>Model Limitations</h2>

                <h3>1. Aerodynamic Limitations</h3>
                <ul>
                    <li><strong>Simplified Drag Model:</strong><br>
                    Drag is calculated using a simple parabolic polar (<i>C<sub>D</sub> = C<sub>D0</sub> + k C<sub>L</sub><sup>2</sup></i>). While mast drag is included, interference drag between components is ignored.</li>
                </ul>

                <h3>2. Biomechanical Limitations</h3>
                <ul>
                    <li><strong>Infinite Muscle Strength:</strong><br>
                    The rider is modeled as an ideal force generator. The simulation might say "Requires 1200 Watts," but it doesn't know that a human cannot generate 1200 Watts. It does not implement Hill's Muscle Equation (the trade-off between force and speed).</li>
                    <li><strong>Perfectly Rigid Transmission:</strong><br>
                    The "Two-Mass Model" assumes the board and legs move as one solid unit relative to the water forces. It ignores the flex of the mast and the fuselage, which can dampen energy transfer.</li>
                    <li><strong>Forced Kinematics (The "Rail" Effect):</strong><br>
                    The motion is defined by math (<i>z = A cos(&omega;t)</i>), not by forces. The board is essentially moving on a predefined invisible rail.<br>
                    <em>Consequence: If the rider stops pedaling (power = 0), the simulation doesn't show the board slowing down or sinking; it just shows "Rider Force = 0". The board never "crashes."</em></li>
                </ul>

                <h3>3. Mathematical Simplifications</h3>
                <ul>
                    <li><strong>Quasi-Steady Assumption:</strong><br>
                    The solver calculates forces based only on the current instant's velocity and angle. It ignores "unsteady aerodynamics" (Theodorsen effects/Wagner function), where the wake from the previous stroke affects the current lift. This is usually acceptable for low frequencies but becomes inaccurate above ~2-3 Hz.</li>
                </ul>
            </div>
        </details>
    </div>

<script>
/**
 * PUMP FOIL SIMULATOR
 */

// --- CONFIGURATION ---
const CONFIG = {
    mass: 70.0,          // Total mass (Rider + Board) in kg
    U: 20.0 / 3.6,       // Forward speed in m/s (converted from km/h)
    rho: 1000.0,         // Water density in kg/mÂ³
    S: 0.135,            // Wing area in mÂ² (e.g., 1350 cmÂ² = 0.135 mÂ²)
    Cd0: 0.013,          // Parasitic Drag Coefficient (0.015=Pro, 0.02=Std, 0.03=Draggy)
    k: 0.05,             // Induced Drag Factor (recalculated based on AR)
    g: 9.81,             // Gravity (m/sÂ²)
    visual_size_m: 0.4,  // Visual scale for foil chord length
    // Scales
    scale_L: 0.5, scale_D: 0.5, scale_T: 0.5, scale_R: 0.5, scale_N: 0.5, scale_W: 0.5, scale_Stab_L: 0.5, scale_Stab_D: 0.5,
    AR: 13.9,            // Aspect Ratio (SpanÂ² / Area)
    
    // --- ADD THESE NEW LINES ---
    S_stab: 0.012,       // Stabilizer Area in m2 (e.g., 250cm2)
    AR_stab: 8.0,        // Stabilizer Aspect Ratio
    fuselage_len: 0.60,  // Distance from Mast to Stabilizer (m)
    stab_angle: -1.0,    // Stabilizer incidence angle (degrees) - usually negative!
    rider_offset: 0.0,   // Rider's feet position relative to CoL (m)
    ride_height: 0.20,   // Average depth of the wing (m)
    
    // Adjustable Parameters
    pitch_trim_deg: 3.3,    // Base pitch angle in degrees
    phase_shift_deg: 90.0,  // Phase difference between Heave and Pitch
    swing_weight_ratio: 0.4, // Percentage of body mass considered moving (legs + arms)
    elastic_efficiency: 1.0,  // Rider elastic efficiency
    asymmetry_factor: 0.0
};

// --- VISIBILITY STATE ---
const VISIBILITY = { lift: true, drag: true, rider: true, thrust: true, assembly: true, weight: false, net: false, stab: true };

// --- STATE ---
let state = {
    t: 0,
    dt: 0.01,
    historyTimer: 0,
    paused: false,
    slowMotion: false,
    freq: 1.65,
    heave_amp: 0.13,
    pathX: [],
    pathZ: [],
    liftHistory: [],
    thrustHistory: [],
    avgThrustHistory: [],
    avgLiftHistory: [],
    powerHistory: [],
    avgPowerHistory: [],
    arithmeticAvgPowerHistory: [],
    linearPowerHistory: [],
    rotationalPowerHistory: [],
    gForceHistory: [],
    avgGForceHistory: []
};

// --- NACA PROFILE ---
function getNACA00xx(thickness, points) {
    const coords = [];
    for (let i = 0; i <= points; i++) {
        const beta = (i / points) * Math.PI;
        const x = (1 - Math.cos(beta)) / 2;
        const yt = 5 * thickness * (0.2969 * Math.sqrt(x) - 0.1260 * x - 0.3516 * Math.pow(x, 2) + 0.2843 * Math.pow(x, 3) - 0.1015 * Math.pow(x, 4));
        coords.push({x: x, y: yt});
    }
    return coords;
}
const foilShape = getNACA00xx(0.15, 40);

// --- DOM ELEMENTS ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const ctxLift = document.getElementById('graphLift').getContext('2d');
const ctxThrust = document.getElementById('graphThrust').getContext('2d');
const ctxPower = document.getElementById('graphPower').getContext('2d');
const ctxAvgPower = document.getElementById('graphAvgPower').getContext('2d');
const ctxPowerComp = document.getElementById('graphPowerComp').getContext('2d');
const ctxGForce = document.getElementById('graphGForce').getContext('2d');

const ui = {
    time: document.getElementById('val-time'),
    watts: document.getElementById('val-watts'),
    arithAvgWatts: document.getElementById('val-arith-avg-watts'),
    avgWatts: document.getElementById('val-avg-watts'),
    avgThrust: document.getElementById('val-avg-thrust'),
    
    // Angle Displays
    pitch: document.getElementById('val-pitch'),
    aoa: document.getElementById('val-aoa'),
    
    dispFreq: document.getElementById('disp-freq'),
    dispPpm: document.getElementById('disp-ppm'),
    dispAmp: document.getElementById('disp-amp'),
    dispAsym: document.getElementById('disp-asym'),
    dispSize: document.getElementById('disp-size'),
    dispSpeed: document.getElementById('disp-speed'),
    dispMass: document.getElementById('disp-mass'),
    dispArea: document.getElementById('disp-area'),
    dispAr: document.getElementById('disp-ar'),
    dispCd0: document.getElementById('disp-cd0'),
    dispTrim: document.getElementById('disp-trim'),
    dispPhase: document.getElementById('disp-phase'),
    dispSwing: document.getElementById('disp-swing'),
    dispElastic: document.getElementById('disp-elastic'),
    dispStabAngle: document.getElementById('disp-stab-angle'),
    dispStabArea: document.getElementById('disp-stab-area'),
    dispStabAr: document.getElementById('disp-stab-ar'),
    dispFuseLen: document.getElementById('disp-fuse-len'),
    dispOffset: document.getElementById('disp-offset'),
    dispHeight: document.getElementById('disp-height')
};

// --- PHYSICS ENGINE ---
function calculatePhysics(t) {
    const omega = 2 * Math.PI * state.freq;
    
    // --- 1. CONFIGURATION FOR 2-MASS MODEL (LEGS + BOARD) ---
    // Standard anthropometry: Legs (~35%) + Arms (~10%) + Hips (~15%).
    // Aggressive pumping can involve >50% of body mass moving relative to head.
    // The "Moving Mass" is the Board + Active Body Parts.
    // The "Fixed Mass" is the Inertial Anchor (Head/Upper Torso).
    
    const m_board_gear = 8.0; // Foil + Board + Wet wetusit (kg)
    const m_legs = CONFIG.mass * CONFIG.swing_weight_ratio;
    const m_moving = m_board_gear + m_legs; 
    // m_moving is the mass we must accelerate violently (~30-35kg total)
    
    // --- 2. KINEMATICS (Moving Mass Motion) ---
    const vz_max = state.heave_amp * omega;
    const gamma_max = Math.atan2(vz_max, CONFIG.U);
    const pitch_amp = gamma_max * 0.90; 
    
    const pitch_trim = CONFIG.pitch_trim_deg * (Math.PI / 180);
    const phase_rad = CONFIG.phase_shift_deg * (Math.PI / 180);

    // Position (z), Velocity (vz), Acceleration (az) of the FEET/BOARD
    const phi = omega * t;
    // Asymmetric pumping profile: Quick Down / Slow Up (Time Warping)
    // psi = phi - C * cos(phi)
    const psi = phi - CONFIG.asymmetry_factor * Math.cos(phi);
    const dpsi = omega * (1 + CONFIG.asymmetry_factor * Math.sin(phi));
    const ddpsi = (omega * omega) * CONFIG.asymmetry_factor * Math.cos(phi);
    
    const z = state.heave_amp * Math.cos(psi);
    const vz = -state.heave_amp * Math.sin(psi) * dpsi;
    const az = -state.heave_amp * (Math.cos(psi) * (dpsi * dpsi) + Math.sin(psi) * ddpsi);
    
    // Pitch follows the warped phase to stay in sync
    const theta = pitch_trim + pitch_amp * Math.cos(psi + phase_rad);

    // Pitch Angular Velocity (rad/s)
    const dTheta = -pitch_amp * Math.sin(psi + phase_rad) * dpsi;

    // --- 3. AERODYNAMICS (FRONT WING) ---
    const x = CONFIG.U * t;
    const vx = CONFIG.U;
    
    const gamma = Math.atan2(vz, vx);
    const alpha = theta - gamma;
    const v_sq = vx*vx + vz*vz;
    
    // --- STALL MODEL (Replaces simple linear calc) ---
    const stall_angle_deg = 13.0;
    const stall_rad = stall_angle_deg * (Math.PI / 180);
    const alpha_abs = Math.abs(alpha);
    const sign = Math.sign(alpha);

    // Base Lift Slope
    const lift_slope = (2 * Math.PI) / (1 + 2 / CONFIG.AR);
    
    let Cl, Cd_profile;

    if (alpha_abs < stall_rad) {
        // Linear Region
        Cl = lift_slope * alpha;
        const k = 1 / (Math.PI * CONFIG.AR);
        Cd_profile = CONFIG.Cd0 + k * (Cl * Cl);
    } else {
        // Stall Region
        const max_Cl = lift_slope * stall_rad;
        Cl = max_Cl * sign; 
        const excess_rad = alpha_abs - stall_rad;
        Cd_profile = 0.05 + (excess_rad * 2.0); 
    }
    
    const L_mag = 0.5 * CONFIG.rho * CONFIG.S * Cl * v_sq;
    const D_mag = 0.5 * CONFIG.rho * CONFIG.S * Cd_profile * v_sq;
    
    let Lx = -L_mag * Math.sin(gamma); let Lz = L_mag * Math.cos(gamma);
    let Dx = -D_mag * Math.cos(gamma); let Dz = -D_mag * Math.sin(gamma);
    
    // --- 3b. AERODYNAMICS (STABILIZER) ---
    // 1. Calculate Downwash Angle (epsilon) caused by front wing
    // Approximation: epsilon = 2 * CL / (pi * AR)
    const epsilon = (2 * Cl) / (Math.PI * CONFIG.AR);
    
    // 2. Local Angle of Attack for Stabilizer
    // We calculate the actual vertical velocity at the stabilizer, accounting for pitch rotation.
    // vz_stab = vz_front_wing - (angular_velocity * fuselage_length)
    const vz_stab = vz - (dTheta * CONFIG.fuselage_len);
    const gamma_stab = Math.atan2(vz_stab, vx);

    // Alpha_stab = BoardPitch + StabAngle - FlightPathAngle_Stab - Downwash
    const stab_rad = CONFIG.stab_angle * (Math.PI / 180);
    const alpha_stab = theta + stab_rad - gamma_stab - epsilon;
    
    // 3. Stabilizer Lift (Usually Downforce, so likely negative)
    const AR_stab = CONFIG.AR_stab; 
    const Cl_stab = (2 * Math.PI * alpha_stab) / (1 + 2 / AR_stab);
    const v_sq_stab = vx*vx + vz_stab*vz_stab; // Local velocity squared
    const L_stab_mag = 0.5 * CONFIG.rho * CONFIG.S_stab * Cl_stab * v_sq_stab;
    
    // Resolve Forces (using gamma_stab)
    let L_stab_z = L_stab_mag * Math.cos(gamma_stab); 
    let L_stab_x = -L_stab_mag * Math.sin(gamma_stab);

    // Add Stabilizer Drag (Profile drag + Induced)
    const D_stab_mag = 0.5 * CONFIG.rho * CONFIG.S_stab * (0.02 + (Cl_stab*Cl_stab)/(Math.PI*AR_stab)) * v_sq_stab;
    let D_stab_x = -D_stab_mag * Math.cos(gamma_stab); 
    let D_stab_z = -D_stab_mag * Math.sin(gamma_stab);

    // --- 3c. VARIABLE MAST DRAG & SURFACE BREACH ---
    const mean_depth = CONFIG.ride_height;  
    let depth = mean_depth - z;
    
    // Initialize mast drag components
    let D_mast_x = 0;
    let D_mast_z = 0;

    if (depth < 0) {
        // Breach!
        Lz = 0; Lx = 0;
        L_stab_z = 0; L_stab_x = 0;
        Dz = 0; Dx = 0;
        D_stab_z = 0; D_stab_x = 0;
        depth = 0; 
    }

    // Mast Drag
    const mast_thick = 0.015;    
    const Cd_mast = 0.12;        
    const area_mast = depth * mast_thick;
    const D_mast_mag = 0.5 * CONFIG.rho * area_mast * Cd_mast * v_sq;
    
    D_mast_x = -D_mast_mag * Math.cos(gamma);
    D_mast_z = -D_mast_mag * Math.sin(gamma);

    // --- 4. DYNAMICS & FORCES ---
    
    // Total Vertical Hydro Force
    // Note: This includes Circulatory Lift & Drag, but EXCLUDES Added Mass (which is modeled as inertia)
    const F_hydro_z = Lz + Dz + L_stab_z + D_stab_z + D_mast_z;
    const F_hydro_x = Lx + Dx + L_stab_x + D_stab_x + D_mast_x;

    // Wing Geometry (Added Mass)
    const span = Math.sqrt(CONFIG.AR * CONFIG.S);
    const chord = CONFIG.S / span;
    const m_33 = CONFIG.rho * Math.PI * Math.pow(chord / 2, 2) * span;
    const added_mass = m_33 * Math.pow(Math.cos(theta), 2);

    // F_inertia_moving: Force needed to accelerate Board + Legs
    const F_inertia_moving = m_moving * (CONFIG.g + az);

    // F_legs_push: The force the TORSO exerts on the LEGS to drive them.
    let F_legs_push = F_hydro_z - F_inertia_moving - added_mass * az;
    const F_rider_action = Math.max(0, F_legs_push); 

    // --- 5. MOMENTS (Summed at Center of Lift) ---
    
    // A. Front Wing Moment
    // By definition, if we pivot at CoL, the moment is 0.
    const M_front = 0;
    
    // B. Stabilizer Moment
    // Torque = Force * Distance. We define Nose Up as Positive Torque.
    // Force L_stab_z is usually negative (down). Lever is negative (back).
    // To get positive torque from downforce on tail: Torque = - (L_stab_z * fuselage_len)
    const M_stab = -(L_stab_z * CONFIG.fuselage_len);
    

    // D. Rider Offset Moment (The "Imbalance" variable)
    // Standing forward (Positive offset) pushes nose DOWN (Negative Torque).
    const M_rider = -(F_rider_action * CONFIG.rider_offset);

    // Total Moment the Rider must fight
    const M_total = M_stab + M_rider;

    // --- 6. POWER ---
    
    // Linear Power
    let rawLegPower = F_legs_push * (-vz);
    if (vz > 0) rawLegPower = 0;
    
    // Rotational Power
    // Rider applies counter-torque: -M_total
    // Use abs() because human muscles consume metabolic energy to resist torque even if technically "absorbing" work.
    const rotPower = Math.abs(M_total * dTheta);

    // Total Power
    let power = Math.max(0, rawLegPower * CONFIG.elastic_efficiency) + rotPower;

    // Weight Vector (Gravity)
    const Wz = -CONFIG.mass * CONFIG.g;
    
    // Apparent Weight (G-Force)
    // For strapless riding, we clamp this to 0. You cannot feel "negative weight" (being pulled down).
    // If the board accelerates down > 1g, you just float (0g).
    const W_apparent_z = -CONFIG.mass * Math.max(0, CONFIG.g + az);

    // --- 6. OUTPUTS ---
    const Rx = 0; 
    const Rz = -F_rider_action; 

    // Calculate Net Force (Sum of all forces)
    // Horizontal Net: Lift_x + Drag_x (Rider and Gravity are vertical)
    const NetFx = F_hydro_x;
    // Vertical Net: Lift_z + Drag_z 
    const NetFz = F_hydro_z + Wz;
    
    return {
        x, z, alpha, gamma, theta, vz, az,
        Lx, Lz, Dx: Dx + D_mast_x, Dz: Dz + D_mast_z, Rx, Rz, Wz, W_apparent_z, NetFx, NetFz,
        thrust: F_hydro_x, 
        riderForce: F_rider_action,
        power: power,
        rawPower: rawLegPower,
        L_stab_x, L_stab_z, D_stab_x, D_stab_z,
        rotPower: rotPower,
        isStalled: alpha_abs >= stall_rad,
        F_hydro_z, F_hydro_x
    };
}
 
// --- DRAWING ---
function drawArrow(ctx, startX, startY, u, v, color, scale, user_scale, maxLen = 150) {
    let len = Math.sqrt(u*u + v*v) * scale * user_scale;
    const MAX_LEN_PX = maxLen;
    let clamp = 1.0;
    if (len > MAX_LEN_PX) clamp = MAX_LEN_PX / len;
    const finalU = u * scale * user_scale * clamp;
    const finalV = v * scale * user_scale * clamp;
    const endX = startX + finalU;
    const endY = startY - finalV; 
    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
    ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke();
    const angle = Math.atan2(-finalV, finalU); const headLen = 10;
    ctx.beginPath(); ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
    ctx.fillStyle = color; ctx.fill();
}

function drawSimpleGraph(ctx, data, title, colorPositive, colorNegative, data2, color2, minScale) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    
    // Scale factor for High DPI (assuming base height of 60px)
    const scale = h / 80;

    ctx.clearRect(0, 0, w, h);

    const fontStack = "Verdana, Arial, sans-serif";
    
    const leftMargin = 50 * scale;
    const rightMargin = 10 * scale;
    const topMargin = 20 * scale;
    const bottomMargin = 15 * scale;

    // Title
    ctx.font =  (8 * scale) + "px " + fontStack;
    ctx.fillStyle = "#333";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(title.toUpperCase(), leftMargin, 4 * scale);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    if (data.length < 2) return;

    // Scaling
    let maxVal;
    let max1 = 0;
    if (data.length > 0) {
        if (colorNegative) {
            max1 = Math.max(...data.map(v => Math.abs(v)));
        } else {
            max1 = Math.max(...data);
        }
    }
    let max2 = 0;
    if (data2 && data2.length > 0) {
        max2 = Math.max(...data2);
    }
    maxVal = Math.max(max1, max2);
    
    if (minScale) maxVal = Math.max(maxVal, minScale);

    if (!isFinite(maxVal) || maxVal <= 1) maxVal = 10;

    const midY = colorNegative ? (topMargin + plotH / 2) : (topMargin + plotH);
    const scaleY = colorNegative ? (plotH / 2) / maxVal : (plotH) / maxVal;

    // Grid & Axis
    ctx.strokeStyle = '#e4e4e7'; // Zinc-200
    ctx.lineWidth = 1 * scale;
    
    // Zero line
    ctx.beginPath(); 
    ctx.moveTo(leftMargin, midY); 
    ctx.lineTo(w - rightMargin, midY); 
    ctx.stroke();

    // Max line
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(w - rightMargin, topMargin);
    ctx.stroke();

    if (colorNegative) {
        ctx.beginPath();
        ctx.moveTo(leftMargin, h - bottomMargin);
        ctx.lineTo(w - rightMargin, h - bottomMargin);
        ctx.stroke();
    }

    // Labels
    ctx.fillStyle = "#444";
    ctx.font =  (8 * scale) + "px " + fontStack;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";

    if (colorNegative) {
        ctx.fillText(maxVal.toFixed(1), leftMargin - 6 * scale, topMargin);
        ctx.fillText('0', leftMargin - 6 * scale, midY);
        ctx.fillText((-maxVal).toFixed(1), leftMargin - 6 * scale, h - bottomMargin);
    } else {
        ctx.fillText(maxVal.toFixed(1), leftMargin - 6 * scale, topMargin);
        ctx.fillText('0', leftMargin - 6 * scale, h - bottomMargin);
    }

    // Plot
    const stepX = plotW / Math.max(1, data.length - 1);
    const pts = [];
    for (let i = 0; i < data.length; i++) {
        pts.push({
            x: leftMargin + i * stepX,
            y: midY - (data[i] * scaleY)
        });
    }

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    if (colorNegative) {
        // 1. Positive Area
        ctx.save();
        ctx.beginPath();
        ctx.rect(leftMargin, topMargin - 2 * scale, plotW, midY - topMargin + 2 * scale);
        ctx.clip();
        
        ctx.beginPath();
        ctx.moveTo(pts[0].x, midY);
        for (let p of pts) ctx.lineTo(p.x, p.y);
        ctx.lineTo(pts[pts.length-1].x, midY);
        ctx.closePath();
        
        let grad = ctx.createLinearGradient(0, topMargin, 0, midY);
        grad.addColorStop(0, colorPositive); 
        grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = grad;
        ctx.fill();
        
        ctx.strokeStyle = colorPositive.replace(/[\d.]+\)$/, '1)'); 
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();
        ctx.restore();

        // 2. Negative Area
        ctx.save();
        ctx.beginPath();
        ctx.rect(leftMargin, midY, plotW, h - bottomMargin - midY + 2 * scale);
        ctx.clip();
        
        ctx.beginPath();
        ctx.moveTo(pts[0].x, midY);
        for (let p of pts) ctx.lineTo(p.x, p.y);
        ctx.lineTo(pts[pts.length-1].x, midY);
        ctx.closePath();
        
        grad = ctx.createLinearGradient(0, midY, 0, h - bottomMargin);
        grad.addColorStop(0, "rgba(255,255,255,0)");
        grad.addColorStop(1, colorNegative);
        ctx.fillStyle = grad;
        ctx.fill();
        
        ctx.strokeStyle = colorNegative.replace(/[\d.]+\)$/, '1)');
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();
        ctx.restore();

    } else {
        ctx.beginPath();
        ctx.moveTo(pts[0].x, h - bottomMargin);
        for (let p of pts) ctx.lineTo(p.x, p.y);
        ctx.lineTo(pts[pts.length-1].x, h - bottomMargin);
        ctx.closePath();

        let grad = ctx.createLinearGradient(0, topMargin, 0, h - bottomMargin);
        grad.addColorStop(0, colorPositive);
        grad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.beginPath();
        for (let i = 0; i < pts.length; i++) {
            if (i===0) ctx.moveTo(pts[i].x, pts[i].y);
            else ctx.lineTo(pts[i].x, pts[i].y);
        }
        ctx.strokeStyle = colorPositive.replace(/[\d.]+\)$/, '1)');
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();
    }

    if (data2 && data2.length > 1) {
        ctx.beginPath();
        for (let i = 0; i < data2.length; i++) {
            const px = leftMargin + i * stepX;
            const py = midY - (data2[i] * scaleY);
            if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = color2;
        ctx.lineWidth = 2 * scale;
        ctx.stroke();
    }
}

function drawSignGraph(ctx, data, title) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const leftMargin = 44;
    const rightMargin = 8;
    const topMargin = 6;
    const bottomMargin = 6;

    ctx.font = "12px sans-serif";
    ctx.fillStyle = "#444";
    ctx.fillText(title, leftMargin, 12);

    const plotW = w - leftMargin - rightMargin;
    const plotH = h - topMargin - bottomMargin;

    // Draw Y axis (small)
    ctx.strokeStyle = '#ccc';
    ctx.beginPath();
    ctx.moveTo(leftMargin, topMargin);
    ctx.lineTo(leftMargin, h - bottomMargin);
    ctx.stroke();

    if (!data || data.length === 0) return;

    const stepX = plotW / Math.max(1, data.length - 1);

    for (let i = 0; i < data.length; i++) {
        const val = data[i];
        const px = leftMargin + i * stepX;
        const wRect = Math.max(1, Math.ceil(stepX));
        ctx.fillStyle = (val >= 0) ? 'rgba(0,160,0,0.5)' : 'rgba(220,0,0,0.45)';
        ctx.fillRect(px, topMargin, wRect, plotH);
    }

    // Draw a thin separator line at mid (zero) for clarity
    ctx.strokeStyle = '#eee';
    ctx.beginPath(); ctx.moveTo(leftMargin, topMargin + plotH/2); ctx.lineTo(w - rightMargin, topMargin + plotH/2); ctx.stroke();
}

function drawSustainabilityGauge(ctx, avgThrust, maxThrustRef) {
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    ctx.clearRect(0, 0, w, h);

    const margin = 8;
    const gaugeW = w - 2 * margin;
    const gaugeH = h - 2 * margin;
    const centerX = margin + gaugeW / 2;
    const centerY = margin + gaugeH / 2;

    // Clamp avgThrust to reasonable range
    const clampedThrust = Math.max(-maxThrustRef, Math.min(maxThrustRef, avgThrust));
    const normalized = clampedThrust / maxThrustRef; // -1 to +1

    // Background bar (light gray)
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(margin, margin, gaugeW, gaugeH);

    // Split into left (negative/red) and right (positive/green) halves
    const halfW = gaugeW / 2;

    // Left half: negative/deceleration (red)
    ctx.fillStyle = 'rgba(255, 100, 100, 0.2)';
    ctx.fillRect(margin, margin, halfW, gaugeH);

    // Right half: positive/acceleration (green)
    ctx.fillStyle = 'rgba(100, 200, 100, 0.2)';
    ctx.fillRect(margin + halfW, margin, halfW, gaugeH);

    // Fill indicator based on normalized thrust
    if (normalized < 0) {
        // Deceleration: fill from center left
        const fillW = Math.abs(normalized) * halfW;
        ctx.fillStyle = 'rgba(220, 50, 50, 0.6)';
        ctx.fillRect(centerX - fillW, margin, fillW, gaugeH);
    } else {
        // Acceleration: fill from center right
        const fillW = normalized * halfW;
        ctx.fillStyle = 'rgba(80, 180, 80, 0.6)';
        ctx.fillRect(centerX, margin, fillW, gaugeH);
    }

    // Center line (zero)
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centerX, margin);
    ctx.lineTo(centerX, margin + gaugeH);
    ctx.stroke();

    // Border
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(margin, margin, gaugeW, gaugeH);

    // Label text
    ctx.fillStyle = '#333';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Decel', margin + 4, margin + 12);
    ctx.textAlign = 'right';
    ctx.fillText('Accel', w - margin - 4, margin + 12);

    // Show numeric value
    ctx.textAlign = 'center';
    ctx.font = 'bold 11px monospace';
    ctx.fillStyle = (normalized >= 0) ? '#008000' : '#c00000';
    ctx.fillText(avgThrust.toFixed(0) + ' N', centerX, margin + gaugeH - 2);
}


// --- UPDATE & RENDER ---
function updatePhysicsState(dtOverride) {
    const dt = dtOverride || state.dt;
    
    // Increment the history timer
    state.historyTimer += dt;

    // Process history updates in fixed steps
    while (state.historyTimer >= state.dt) {
        // Decrement timer by one simulation step
        state.historyTimer -= state.dt;
        
        // Increment simulation time and recalculate physics for the history
        state.t += state.dt;
        if(state.t > 1000) state.t = 0; // Reset time to avoid precision issues
        
        const phys = calculatePhysics(state.t); // Recalculate for the new time
        
        // --- Update History Arrays ---
        state.liftHistory.push(phys.F_hydro_z);
        if (state.liftHistory.length > 1000) state.liftHistory.shift();
        
        state.thrustHistory.push(phys.thrust);
        if (state.thrustHistory.length > 1000) state.thrustHistory.shift();
        
        state.powerHistory.push(phys.power);
        if (state.powerHistory.length > 1000) state.powerHistory.shift();
        
        state.linearPowerHistory.push(Math.max(0, phys.rawPower * CONFIG.elastic_efficiency));
        if (state.linearPowerHistory.length > 1000) state.linearPowerHistory.shift();

        state.rotationalPowerHistory.push(phys.rotPower);
        if (state.rotationalPowerHistory.length > 1000) state.rotationalPowerHistory.shift();
        
        // Track Apparent Weight (Signed Force in Newtons) to ensure avg is exactly 1G
        state.gForceHistory.push(phys.W_apparent_z);
        if (state.gForceHistory.length > 1000) state.gForceHistory.shift();

        // Calculate window (2 cycles) for smoothing
        const cyclePeriod = 1.0 / state.freq;
        const samplesPerCycle = Math.max(1, cyclePeriod / state.dt);
        const windowSize = Math.ceil(samplesPerCycle * 2);
        
        // Power (Normalized & Average)
        let sumFourthPower = 0;
        let sumPower = 0;
        const start = Math.max(0, state.powerHistory.length - windowSize);
        const count = state.powerHistory.length - start;
        for (let i = state.powerHistory.length - 1; i >= start; i--) {
            // Double Check: Ensure we only calculate positive work.
            // Clamp negative values (braking/absorbing) to 0 before averaging.
            const val = Math.max(0, state.powerHistory[i]);
            sumFourthPower += Math.pow(val, 4);
            sumPower += val;
        }
        const avgPower = (count > 0) ? Math.pow(sumFourthPower / count, 0.25) : 0;
        const arithmeticAvgPower = (count > 0) ? sumPower / count : 0;

        state.avgPowerHistory.push(avgPower);
        if (state.avgPowerHistory.length > 1000) state.avgPowerHistory.shift();
        state.arithmeticAvgPowerHistory.push(arithmeticAvgPower);
        if (state.arithmeticAvgPowerHistory.length > 1000) state.arithmeticAvgPowerHistory.shift();

        // Average Thrust (Windowed)
        let thrustSum = 0;
        const startThrust = Math.max(0, state.thrustHistory.length - windowSize);
        const countThrust = state.thrustHistory.length - startThrust;
        for (let i = state.thrustHistory.length - 1; i >= startThrust; i--) {
            thrustSum += state.thrustHistory[i];
        }
        const avgThrust = (countThrust > 0) ? thrustSum / countThrust : 0;
        state.avgThrustHistory.push(avgThrust);
        if (state.avgThrustHistory.length > 1000) state.avgThrustHistory.shift();

        // Average Lift (Windowed)
        let liftSum = 0;
        const startLift = Math.max(0, state.liftHistory.length - windowSize);
        const countLift = state.liftHistory.length - startLift;
        for (let i = state.liftHistory.length - 1; i >= startLift; i--) {
            liftSum += state.liftHistory[i];
        }
        const avgLift = (countLift > 0) ? liftSum / countLift : 0;
        state.avgLiftHistory.push(avgLift);
        if (state.avgLiftHistory.length > 1000) state.avgLiftHistory.shift();

        // Average G-Force (Windowed)
        let gSum = 0;
        const startG = Math.max(0, state.gForceHistory.length - windowSize);
        const countG = state.gForceHistory.length - startG;
        for (let i = state.gForceHistory.length - 1; i >= startG; i--) {
            gSum += state.gForceHistory[i];
        }
        const avgGForce = (countG > 0) ? gSum / countG : 0;
        state.avgGForceHistory.push(avgGForce);
        if (state.avgGForceHistory.length > 1000) state.avgGForceHistory.shift();

        // Update the visual path of the foil (synced with physics steps)
        state.pathX.push(phys.x);
        state.pathZ.push(phys.z);
        if (state.pathX.length > 300) {
            state.pathX.shift();
            state.pathZ.shift();
        }
    }
    
    // Get the most recent averages for the UI display
    const currentAvgPower = state.avgPowerHistory.length > 0 ? state.avgPowerHistory[state.avgPowerHistory.length - 1] : 0;
    const currentArithmeticAvgPower = state.arithmeticAvgPowerHistory.length > 0 ? state.arithmeticAvgPowerHistory[state.arithmeticAvgPowerHistory.length - 1] : 0;
    const currentAvgThrust = state.avgThrustHistory.length > 0 ? state.avgThrustHistory[state.avgThrustHistory.length - 1] : 0;
    const currentAvgLift = state.avgLiftHistory.length > 0 ? state.avgLiftHistory[state.avgLiftHistory.length - 1] : 0;
    const currentAvgGForce = state.avgGForceHistory.length > 0 ? state.avgGForceHistory[state.avgGForceHistory.length - 1] : 0;

    // Calculate smooth physics for rendering (interpolate time using the remainder)
    const smoothPhys = calculatePhysics(state.t + state.historyTimer);

    return { phys: smoothPhys, avgPower: currentAvgPower, arithmeticAvgPower: currentArithmeticAvgPower, avgThrust: currentAvgThrust, avgLift: currentAvgLift, avgGForce: currentAvgGForce };
}

function render(data) {
    const { phys, avgPower, arithmeticAvgPower, avgThrust, avgLift, avgGForce } = data;

    // UI
    ui.time.textContent = state.t.toFixed(2);
    
    // Update New Angle Displays
    ui.pitch.textContent = (phys.theta * 180 / Math.PI).toFixed(1);
    ui.aoa.textContent = (phys.alpha * 180 / Math.PI).toFixed(1);

    ui.watts.textContent = phys.power.toFixed(0);
    ui.arithAvgWatts.textContent = arithmeticAvgPower.toFixed(0);
    ui.avgWatts.textContent = avgPower.toFixed(0);
    
    // Canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const PPU = 100;
    const camX = phys.x * PPU;
    const camOffset = canvas.width / 3;
    
    ctx.save();
    ctx.translate(-camX + camOffset, canvas.height * 0.70);
    
    // Environment
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 1;
    ctx.beginPath();
    const startGrid = Math.floor((phys.x - 2)); const endGrid = Math.floor((phys.x + 8));
    for (let i = startGrid; i <= endGrid; i++) { ctx.moveTo(i * PPU, -500); ctx.lineTo(i * PPU, 500); }
    ctx.moveTo(-10000, 0); ctx.lineTo(10000, 0); ctx.stroke();
    
    // Water Surface
    const surfaceZ = CONFIG.ride_height; 
    const surfaceY = -surfaceZ * PPU;
    ctx.fillStyle = 'rgba(0, 160, 255, 0.1)';
    ctx.fillRect(camX - 2000, surfaceY, 4000, 1000);
    ctx.beginPath(); ctx.moveTo(camX - 2000, surfaceY); ctx.lineTo(camX + 2000, surfaceY);
    ctx.strokeStyle = 'rgba(0, 160, 255, 0.5)'; ctx.lineWidth = 2; ctx.stroke();

    // Trail
    ctx.beginPath(); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
    for(let i=0; i<state.pathX.length; i++){
        const px = state.pathX[i] * PPU; const pz = -state.pathZ[i] * PPU;
        if (i===0) ctx.moveTo(px, pz); else ctx.lineTo(px, pz);
    }
    // Connect trail to current foil position to close the gap
    if (state.pathX.length > 0) {
        ctx.lineTo(phys.x * PPU, -phys.z * PPU);
    }
    ctx.stroke();
    
    const foilCX = phys.x * PPU; const foilCY = -phys.z * PPU;
    
    // Chest position for G-Force vector (defaults to foil center)
    let chestX = foilCX;
    let chestY = foilCY;

    // Foil
    // Foil Assembly (Rigid Body)
    ctx.save(); ctx.translate(foilCX, foilCY); ctx.rotate(-phys.theta); 
    
    // Dimensions
    const mastH = 0.85 * PPU;
    const mastW = 0.1 * PPU;
    const fuseLen = CONFIG.fuselage_len * PPU;
    const fuseRad = 0.015 * PPU;
    const mastX = -0.2 * PPU; 
    const boardL = 1.2 * PPU;
    const boardThick = 0.06 * PPU;

    // Calculate Rider Force Attachment Point (Feet Center)
    const rSinT = Math.sin(phys.theta);
    const rCosT = Math.cos(phys.theta);
    const localFeetX = CONFIG.rider_offset * PPU;
    const localFeetY = -mastH - boardThick;
    const riderForceX = foilCX + (localFeetX * rCosT + localFeetY * rSinT);
    const riderForceY = foilCY + (-localFeetX * rSinT + localFeetY * rCosT);

    if (VISIBILITY.assembly) {
        // 1. Mast & Fuselage & Stabilizer
        ctx.fillStyle = '#444';
        
        // Fuselage (extending backwards from wing at 0,0)
        ctx.fillRect(-fuseLen, -fuseRad, fuseLen, fuseRad*2);
        // Stabilizer (at the back end of fuselage)
        ctx.beginPath(); ctx.ellipse(-fuseLen, 0, 0.12*PPU, 0.015*PPU, 0, 0, Math.PI*2); ctx.fill();
        // Mast (extending up)
        ctx.fillRect(mastX - mastW/2, -mastH, mastW, mastH);

        // 2. Board (on top of mast)
        ctx.fillStyle = '#ccc'; ctx.strokeStyle = '#999';
        ctx.beginPath(); ctx.rect(mastX - boardL/3, -mastH - boardThick, boardL, boardThick);
        ctx.fill(); ctx.stroke();
    }

    // 3. Stickman Rider
    if (VISIBILITY.rider && VISIBILITY.assembly) {
        const fatness = CONFIG.mass / 80.0;
        const limbWidth = 5 * fatness;
        const torsoWidth = 12 * fatness * fatness;

        // Color change for Power Phase
        // Light up when pushing down (Rz < 0) and accelerating downwards (az < 0)
        const isPowerPhase = (phys.rawPower > 0 && phys.az < 0);
        const riderColor = isPowerPhase ? '#f97316' : '#222'; // Orange-500 if powered

        ctx.strokeStyle = riderColor; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        const deckY = -mastH - boardThick;
        const legLen = 0.9 * PPU;
        const torsoLen = 0.55 * PPU;
        const headRad = 0.1 * PPU * Math.sqrt(fatness);
        
        // Crouch: z high (up) -> crouch=1 (bent). z low (down) -> crouch=0 (straight)
        const normZ = (state.heave_amp > 0.0001) ? Math.max(-1, Math.min(1, phys.z / state.heave_amp)) : 0;
        const crouch = (normZ + 1) / 2; 
        
        const curLegLen = legLen * (1.0 - 0.35 * crouch);
        
        // Feet positions (Fixed on board)
        const footRearX = (CONFIG.rider_offset - 0.2) * PPU;
        const footFrontX = footRearX + 0.4 * PPU;

        // Hip stabilized over front foot (World Up)
        const sinT = Math.sin(phys.theta);
        const cosT = Math.cos(phys.theta);
        
        const hipX = footFrontX + curLegLen * sinT;
        const hipY = deckY - curLegLen * cosT;
        
        const kneeBend = 0.25 * PPU * crouch;

        // Legs
        ctx.lineWidth = limbWidth;
        ctx.beginPath(); ctx.moveTo(footRearX, deckY); ctx.quadraticCurveTo(footRearX + (hipX - footRearX)/2 + kneeBend, deckY - curLegLen/2, hipX, hipY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(footFrontX, deckY); ctx.quadraticCurveTo(footFrontX + (hipX - footFrontX)/2 + kneeBend, deckY - curLegLen/2, hipX, hipY); ctx.stroke();
        
        // Torso & Head (Upright in World Space)
        const shoulderX = hipX + torsoLen * sinT;
        const shoulderY = hipY - torsoLen * cosT;

        ctx.lineWidth = torsoWidth;
        ctx.beginPath(); ctx.moveTo(hipX, hipY); ctx.lineTo(shoulderX, shoulderY); ctx.stroke();
        ctx.beginPath(); ctx.fillStyle='#eee'; ctx.lineWidth=2; ctx.arc(shoulderX, shoulderY - headRad, headRad, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        
        // Arms
        const armLen = 0.55 * PPU;
        
        // Arm swing logic: Simulate motion in Z-Y plane (Out of screen / Up-Down)
        // 0 = Down, PI = Up. We map crouch to a range that lifts arms.
        const armAngle = 0.2 + (crouch * 1.3); 
        
        // Projection:
        // Y component (Vertical) varies with cos(angle). 
        // X component (Lateral) is minimized to simulate "out of screen" motion rather than "side-to-side".
        const armDyLocal = armLen * Math.cos(armAngle); 
        const armDxLocal = armLen * 0.2 * Math.sin(armAngle); // Small lateral spread for "elbows out"

        // Shoulders (Facing Screen -> Spread in World X)
        const shoulderSpread = 0.12 * PPU; 
        const sDx = shoulderSpread * cosT;
        const sDy = shoulderSpread * sinT;

        const rShoulderX = shoulderX + sDx; const rShoulderY = shoulderY + sDy;
        const lShoulderX = shoulderX - sDx; const lShoulderY = shoulderY - sDy;

        // Draw Shoulder Line
        ctx.lineWidth = limbWidth;
        ctx.beginPath(); ctx.moveTo(lShoulderX, lShoulderY); ctx.lineTo(rShoulderX, rShoulderY); ctx.stroke();

        // Calculate Arm Vectors rotated by Rider Pitch (theta)
        // Right Arm (+X spread)
        const rDx = (armDxLocal * cosT - armDyLocal * sinT);
        const rDy = (armDxLocal * sinT + armDyLocal * cosT);
        
        // Left Arm (-X spread for symmetry)
        const lDx = (-armDxLocal * cosT - armDyLocal * sinT);
        const lDy = (-armDxLocal * sinT + armDyLocal * cosT);

        const rArmX = rShoulderX + rDx; const rArmY = rShoulderY + rDy;
        const lArmX = lShoulderX + lDx; const lArmY = lShoulderY + lDy;

        ctx.beginPath(); ctx.moveTo(lShoulderX, lShoulderY); ctx.lineTo(lArmX, lArmY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(rShoulderX, rShoulderY); ctx.lineTo(rArmX, rArmY); ctx.stroke();
        
        // Calculate Chest Position (World Space) for G-Force Vector
        // Local Chest is midpoint of torso
        const localChestX = (hipX + shoulderX) / 2;
        const localChestY = (hipY + shoulderY) / 2;
        
        // Transform Local -> World (Rotation is -phys.theta)
        chestX = foilCX + (localChestX * cosT + localChestY * sinT);
        chestY = foilCY + (-localChestX * sinT + localChestY * cosT);
    }

    // 3. Main Wing (NACA Profile) - Centered at (0,0)
    const chordPx = CONFIG.visual_size_m * PPU;
    const toLocalX = (nx) => (0.25 - nx) * chordPx; 
    ctx.beginPath(); ctx.fillStyle = 'black';
    ctx.moveTo(toLocalX(foilShape[0].x), -foilShape[0].y * chordPx);
    for (let i = 1; i < foilShape.length; i++) ctx.lineTo(toLocalX(foilShape[i].x), -foilShape[i].y * chordPx);
    for (let i = foilShape.length - 1; i >= 0; i--) ctx.lineTo(toLocalX(foilShape[i].x), foilShape[i].y * chordPx);
    ctx.fill(); ctx.restore();

    // Vectors
    const vecScale = 0.2; 
    if (VISIBILITY.lift) drawArrow(ctx, foilCX, foilCY, phys.Lx, phys.Lz, 'blue', vecScale, CONFIG.scale_L);
    if (VISIBILITY.drag) drawArrow(ctx, foilCX, foilCY, phys.Dx, phys.Dz, 'red', vecScale, CONFIG.scale_D);
    if (VISIBILITY.rider) {
        // Only draw if there is significant force
        if (Math.abs(phys.Rz) > 1) {
            drawArrow(ctx, riderForceX, riderForceY, phys.Rx, phys.Rz, 'orange', vecScale, CONFIG.scale_R);
        }
    }
    if (VISIBILITY.thrust) drawArrow(ctx, foilCX, foilCY, phys.thrust, 0, 'cyan', vecScale, CONFIG.scale_T);
    if (VISIBILITY.weight) drawArrow(ctx, chestX, chestY, 0, phys.W_apparent_z, 'rgb(255, 251, 0)', vecScale, CONFIG.scale_W, 1000);
    if (VISIBILITY.net) drawArrow(ctx, foilCX, foilCY, phys.NetFx, phys.NetFz, 'lime', vecScale, CONFIG.scale_N);
    
    if (VISIBILITY.stab) {
        // Calculate Stabilizer World Position
        // Local pos: (-CONFIG.fuselage_len, 0)
        const stabDx = -CONFIG.fuselage_len * Math.cos(phys.theta);
        const stabDz = -CONFIG.fuselage_len * Math.sin(phys.theta);
        const stabPX = foilCX + stabDx * PPU;
        const stabPY = foilCY - stabDz * PPU; // Canvas Y is inverted Z
        
        // Draw Stabilizer Lift (Purple)
        drawArrow(ctx, stabPX, stabPY, phys.L_stab_x, phys.L_stab_z, '#d946ef', vecScale, CONFIG.scale_Stab_L);
        
        // Draw Stabilizer Drag (Red)
        drawArrow(ctx, stabPX, stabPY, phys.D_stab_x, phys.D_stab_z, '#ef4444', vecScale, CONFIG.scale_Stab_D);
    }

    if (phys.isStalled) {
        ctx.save();
        if (Math.floor(Date.now() / 150) % 2 === 0) {
            ctx.fillStyle = "#ef4444";
            ctx.font = "bold 14px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("âš ï¸ STALL", foilCX, foilCY - 1.3 * PPU);
        }
        ctx.restore();
    }

    ctx.restore();
    
    // Graphs
    const weight = CONFIG.mass * CONFIG.g;

    drawSimpleGraph(ctxLift, state.liftHistory, "Total Vertical Force (N)", "rgba(59, 130, 246, 0.5)", "rgba(239, 68, 68, 0.5)");
    drawSimpleGraph(ctxThrust, state.thrustHistory, "Net Thrust (N)", "rgba(16, 185, 129, 0.5)", "rgba(244, 63, 94, 0.5)");
    
    const gData = state.gForceHistory.map(v => Math.abs(v) / (weight || 1));
    drawSimpleGraph(ctxGForce, gData, "Rider G-Force (G)", "rgba(255, 215, 0, 0.5)", null, null, null, 1.5);

    drawSimpleGraph(ctxPower, state.powerHistory, "Rider Inst. Power (W)", "rgba(245, 158, 11, 0.5)", "rgba(168, 85, 247, 0.5)");
    drawSimpleGraph(ctxAvgPower, state.avgPowerHistory, "Norm (Org) vs Avg (Blu) Power (W)", "rgba(249, 115, 22, 0.5)", null, state.arithmeticAvgPowerHistory, "rgba(59, 130, 246, 0.8)");
    drawSimpleGraph(ctxPowerComp, state.linearPowerHistory, "Linear (Grn) vs Rotational (Red) Power (W)", "rgba(16, 185, 129, 0.5)", null, state.rotationalPowerHistory, "rgba(239, 68, 68, 0.8)", 250);

    // Update avg lift status bar
    const liftStatusEl = document.getElementById('avgLiftStatus');
    const liftDiff = avgLift - weight;
    
    if (liftDiff < -20) { // Tolerance of 20N
        liftStatusEl.style.backgroundColor = '#ffcdd2';
        liftStatusEl.style.color = '#b71c1c';
        liftStatusEl.textContent = `Avg Lift: Sinking (${avgLift.toFixed(0)} N < ${weight.toFixed(0)} N)`;
    } else if (liftDiff > 20) {
        liftStatusEl.style.backgroundColor = '#bbdefb';
        liftStatusEl.style.color = '#0d47a1';
        liftStatusEl.textContent = `Avg Lift: Climbing (${avgLift.toFixed(0)} N > ${weight.toFixed(0)} N)`;
    } else {
        liftStatusEl.style.backgroundColor = '#c8e6c9';
        liftStatusEl.style.color = '#1b5e20';
        liftStatusEl.textContent = `Avg Lift: Balanced (~${weight.toFixed(0)} N)`;
    }

    // Update avg thrust status bar
    ui.avgThrust.textContent = avgThrust.toFixed(0);
    const statusEl = document.getElementById('avgThrustStatus');
    if (avgThrust < -2) {
        statusEl.style.backgroundColor = '#ffcdd2';
        statusEl.style.color = '#b71c1c';
        statusEl.textContent = 'Avg Thrust: Decelerating : ' + avgThrust.toFixed(0) + ' N';
    } else if (avgThrust > 2) {
        statusEl.style.backgroundColor = '#bbdefb';
        statusEl.style.color = '#0d47a1';
        statusEl.textContent = 'Avg Thrust: Accelerating : ' + avgThrust.toFixed(0) + ' N';
    } else {
        statusEl.style.backgroundColor = '#c8e6c9';
        statusEl.style.color = '#1b5e20';
        statusEl.textContent = 'Avg Thrust: On Target : ' + avgThrust.toFixed(0) + ' N';
    }
    
    // Update Avg G-Force Status
    const gStatusEl = document.getElementById('avgGForceStatus');
    const targetWeight = CONFIG.mass * CONFIG.g;
    // Calculate ratio (e.g., 1.00 G)
    const gRatio = (targetWeight > 0) ? (Math.abs(avgGForce) / targetWeight) : 0;
    
    if (Math.abs(gRatio - 1.0) > 0.02) { // 2% tolerance
        gStatusEl.style.backgroundColor = '#ffcdd2'; // Red warning
        gStatusEl.style.color = '#b71c1c';
        gStatusEl.textContent = `Avg Rider G-Force: Deviation (${gRatio.toFixed(2)} G)`;
    } else {
        gStatusEl.style.backgroundColor = '#e1bee7'; // Purple/Good
        gStatusEl.style.color = '#4a148c';
        gStatusEl.textContent = `Avg Rider G-Force: OK (${gRatio.toFixed(2)} G)`;
    }
}

// --- LISTENERS ---
document.getElementById('in-freq').addEventListener('input', (e) => { state.freq = parseFloat(e.target.value); ui.dispFreq.textContent = state.freq.toFixed(2); ui.dispPpm.textContent = (state.freq * 60).toFixed(0); });
document.getElementById('in-amp').addEventListener('input', (e) => { 
    let val = parseFloat(e.target.value);
    if (val > CONFIG.ride_height - 0.02) {
        CONFIG.ride_height = Math.min(0.80, val + 0.02);
        document.getElementById('in-height').value = CONFIG.ride_height;
        ui.dispHeight.textContent = CONFIG.ride_height.toFixed(2);
    }
    state.heave_amp = val; 
    ui.dispAmp.textContent = state.heave_amp.toFixed(2); 
});
document.getElementById('in-asym').addEventListener('input', (e) => { CONFIG.asymmetry_factor = parseFloat(e.target.value); ui.dispAsym.textContent = CONFIG.asymmetry_factor.toFixed(2); });
document.getElementById('in-size').addEventListener('input', (e) => { CONFIG.visual_size_m = parseFloat(e.target.value); ui.dispSize.textContent = CONFIG.visual_size_m.toFixed(2); });
document.getElementById('in-speed').addEventListener('input', (e) => { const kph = parseFloat(e.target.value); CONFIG.U = kph / 3.6; ui.dispSpeed.textContent = kph.toFixed(1); });
document.getElementById('in-mass').addEventListener('input', (e) => { CONFIG.mass = parseFloat(e.target.value); ui.dispMass.textContent = CONFIG.mass.toFixed(0); });
document.getElementById('in-area').addEventListener('input', (e) => { const cm2 = parseFloat(e.target.value); CONFIG.S = cm2 / 10000; ui.dispArea.textContent = cm2.toFixed(0); });
document.getElementById('in-ar').addEventListener('input', (e) => { CONFIG.AR = parseFloat(e.target.value); ui.dispAr.textContent = CONFIG.AR.toFixed(1); });
document.getElementById('in-cd0').addEventListener('input', (e) => { CONFIG.Cd0 = parseFloat(e.target.value); ui.dispCd0.textContent = CONFIG.Cd0.toFixed(3); });
document.getElementById('in-trim').addEventListener('input', (e) => { CONFIG.pitch_trim_deg = parseFloat(e.target.value); ui.dispTrim.textContent = CONFIG.pitch_trim_deg.toFixed(1); });
document.getElementById('in-phase').addEventListener('input', (e) => { CONFIG.phase_shift_deg = parseFloat(e.target.value); ui.dispPhase.textContent = CONFIG.phase_shift_deg.toFixed(0); });
document.getElementById('in-swing').addEventListener('input', (e) => { CONFIG.swing_weight_ratio = parseFloat(e.target.value); ui.dispSwing.textContent = (CONFIG.swing_weight_ratio * 100).toFixed(0); });
document.getElementById('in-elastic').addEventListener('input', (e) => { const val = parseFloat(e.target.value); CONFIG.elastic_efficiency = 1.0 - (val / 100.0); ui.dispElastic.textContent = val.toFixed(0); });
document.getElementById('chk-slowmo').addEventListener('change', (e) => { state.slowMotion = e.target.checked; });
document.getElementById('in-stab-angle').addEventListener('input', (e) => { CONFIG.stab_angle = parseFloat(e.target.value); ui.dispStabAngle.textContent = CONFIG.stab_angle.toFixed(1); });
document.getElementById('in-stab-area').addEventListener('input', (e) => { const val = parseFloat(e.target.value); CONFIG.S_stab = val / 10000; ui.dispStabArea.textContent = val.toFixed(0); });
document.getElementById('in-stab-ar').addEventListener('input', (e) => { CONFIG.AR_stab = parseFloat(e.target.value); ui.dispStabAr.textContent = CONFIG.AR_stab.toFixed(1); });
document.getElementById('in-fuse-len').addEventListener('input', (e) => { CONFIG.fuselage_len = parseFloat(e.target.value); ui.dispFuseLen.textContent = CONFIG.fuselage_len.toFixed(2); });
document.getElementById('in-offset').addEventListener('input', (e) => { CONFIG.rider_offset = parseFloat(e.target.value); ui.dispOffset.textContent = CONFIG.rider_offset.toFixed(2); });
document.getElementById('in-height').addEventListener('input', (e) => { 
    let val = parseFloat(e.target.value);
    if (val < state.heave_amp + 0.02) {
        state.heave_amp = Math.max(0.0, val - 0.02);
        document.getElementById('in-amp').value = state.heave_amp;
        ui.dispAmp.textContent = state.heave_amp.toFixed(2);
    }
    CONFIG.ride_height = val; 
    ui.dispHeight.textContent = CONFIG.ride_height.toFixed(2); 
});

document.getElementById('btn-optimize').addEventListener('click', () => {
    const btn = document.getElementById('btn-optimize');
    const originalText = btn.textContent;
    btn.textContent = "CALCULATING...";
    
    setTimeout(() => {
        runOptimization();
        btn.textContent = originalText;
    }, 10);
});

function runOptimization() {
    const targetLift = CONFIG.mass * CONFIG.g;
    const targetThrust = 0; 
    const liftTolerance = 5.0;
    const thrustTolerance = 2.0;

    // Backup
    const originalFreq = state.freq;
    const originalAmp = state.heave_amp;
    const originalTrim = CONFIG.pitch_trim_deg;
    const originalAsym = CONFIG.asymmetry_factor;
    const originalPhase = CONFIG.phase_shift_deg;
    const originalHeight = CONFIG.ride_height;

    // Check locks
    const lockFreq = document.getElementById('lock-freq').checked;
    const lockAmp = document.getElementById('lock-amp').checked;
    const lockTrim = document.getElementById('lock-trim').checked;
    const lockAsym = document.getElementById('lock-asym').checked;
    const lockPhase = document.getElementById('lock-phase').checked;
    const lockHeight = document.getElementById('lock-height').checked;

    let bestFreq = originalFreq;
    let bestAmp = originalAmp;
    let bestTrim = originalTrim;
    let bestAsym = originalAsym;
    let bestPhase = originalPhase;
    let bestHeight = originalHeight;
    let bestCost = Infinity;

    // Helper
    function evaluate(f, a, tr, as, ph, h) {
        state.freq = f;
        state.heave_amp = a;
        CONFIG.pitch_trim_deg = tr;
        CONFIG.asymmetry_factor = as;
        CONFIG.phase_shift_deg = ph;
        CONFIG.ride_height = h;

        let sumLift = 0;
        let sumThrust = 0;
        let sumPower = 0;
        let sumGForce = 0;
        let count = 0;
        
        const period = 1.0 / f;
        const dt = 0.02; 
        const steps = Math.ceil((2 * period) / dt);

        for (let i = 0; i < steps; i++) {
            const t = i * dt;
            const phys = calculatePhysics(t);
            sumLift += phys.F_hydro_z;
            sumThrust += phys.thrust;
            sumPower += phys.power;
            sumGForce += Math.abs(phys.W_apparent_z);
            count++;
        }

        const avgLift = sumLift / count;
        const avgThrust = sumThrust / count;
        const avgPower = sumPower / count;
        const avgGForce = sumGForce / count;

        const liftErr = Math.abs(avgLift - targetLift);
        const thrustErr = Math.abs(avgThrust - targetThrust);
        const gForceErr = Math.abs(avgGForce - targetLift);
        
        if (isNaN(liftErr) || isNaN(thrustErr)) return { cost: Infinity };

        // Cost Function with Dead Zone
        // We allow errors up to a small threshold without penalty.
        // This lets the optimizer minimize power freely within the valid region.
        const liftSafe = 2.0; 
        const thrustSafe = 1.0;
        const gForceSafe = 5.0;
        
        const liftPen = Math.max(0, liftErr - liftSafe);
        const thrustPen = Math.max(0, thrustErr - thrustSafe);
        const gForcePen = Math.max(0, gForceErr - gForceSafe);
        
        // Heavy penalty for leaving the safe zone
        const cost = avgPower + 10000 * (liftPen + thrustPen + gForcePen);
        
        const isValid = (liftErr < liftTolerance && thrustErr < thrustTolerance && gForceErr < (gForceSafe * 2));
        return { cost: cost, l: avgLift, t: avgThrust, p: avgPower, valid: isValid };
    }

    let bestValidResult = null;
    let bestFallbackResult = null;
    let bestFallbackCost = Infinity;

    const attempts = 30;
    const iterations = 1500;

    for (let attempt = 0; attempt < attempts; attempt++) {
        let currentBestFreq = originalFreq;
        let currentBestAmp = originalAmp;
        let currentBestTrim = originalTrim;
        let currentBestAsym = originalAsym;
        let currentBestPhase = originalPhase;
        let currentBestHeight = originalHeight;
        let currentBestCost = Infinity;

        // Randomize start point for subsequent attempts to explore broader space
        if (attempt > 0) {
            const startScale = 0.5;
            if (!lockFreq) currentBestFreq += (Math.random() - 0.5) * 1.0 * startScale;
            if (!lockAmp) currentBestAmp += (Math.random() - 0.5) * 0.1 * startScale;
            if (!lockTrim) currentBestTrim += (Math.random() - 0.5) * 5.0 * startScale;
            if (!lockAsym) currentBestAsym += (Math.random() - 0.5) * 0.5 * startScale;
            if (!lockPhase) currentBestPhase += (Math.random() - 0.5) * 10.0 * startScale;
            if (!lockHeight) currentBestHeight += (Math.random() - 0.5) * 0.2 * startScale;
        }

        for (let i = 0; i < iterations; i++) {
            const learningRate = 1.0; 
            const scale = learningRate * Math.max(0.1, (1 - i/iterations));

            let f = currentBestFreq + (lockFreq ? 0 : (Math.random() - 0.5) * 1.0 * scale);
            let a = currentBestAmp + (lockAmp ? 0 : (Math.random() - 0.5) * 0.1 * scale);
            let tr = currentBestTrim + (lockTrim ? 0 : (Math.random() - 0.5) * 5.0 * scale);
            let as = currentBestAsym + (lockAsym ? 0 : (Math.random() - 0.5) * 0.5 * scale);
            let ph = currentBestPhase + (lockPhase ? 0 : (Math.random() - 0.5) * 10.0 * scale);
            let h = currentBestHeight + (lockHeight ? 0 : (Math.random() - 0.5) * 0.2 * scale);

            if (!lockFreq) f = Math.max(0.5, Math.min(2.5, f));
            if (!lockAmp) a = Math.max(0.05, Math.min(0.30, a));
            if (!lockTrim) tr = Math.max(-2.0, Math.min(10.0, tr));
            if (!lockAsym) as = Math.max(0.0, Math.min(0.8, as));
            if (!lockPhase) ph = Math.max(80.0, Math.min(110.0, ph));
            if (!lockHeight) h = Math.max(0.10, Math.min(0.80, h));

            if (h < a + 0.02) {
                if (!lockHeight) h = Math.min(0.80, a + 0.02);
                if (h < a + 0.02 && !lockAmp) a = Math.max(0.05, h - 0.02);
            }

            const r = evaluate(f, a, tr, as, ph, h);
            
            if (r.cost < currentBestCost) {
                currentBestCost = r.cost;
                currentBestFreq = f;
                currentBestAmp = a;
                currentBestTrim = tr;
                currentBestAsym = as;
                currentBestPhase = ph;
                currentBestHeight = h;
                
                if (r.valid) {
                    if (!bestValidResult || r.p < bestValidResult.p) {
                        bestValidResult = {
                            f, a, tr, as, ph, h,
                            p: r.p
                        };
                    }
                }
            }
        }

        if (currentBestCost < bestFallbackCost) {
            bestFallbackCost = currentBestCost;
            bestFallbackResult = {
                f: currentBestFreq, a: currentBestAmp, tr: currentBestTrim, 
                as: currentBestAsym, ph: currentBestPhase, h: currentBestHeight
            };
        }
    }

    const finalResult = bestValidResult || bestFallbackResult;

    if (finalResult) {
        state.freq = finalResult.f;
        state.heave_amp = finalResult.a;
        CONFIG.pitch_trim_deg = finalResult.tr;
        CONFIG.asymmetry_factor = finalResult.as;
        CONFIG.phase_shift_deg = finalResult.ph;
        CONFIG.ride_height = finalResult.h;
    }

    // Update UI
    document.getElementById('in-freq').value = state.freq; ui.dispFreq.textContent = state.freq.toFixed(2);
    ui.dispPpm.textContent = (state.freq * 60).toFixed(0);
    document.getElementById('in-amp').value = state.heave_amp; ui.dispAmp.textContent = state.heave_amp.toFixed(2);
    document.getElementById('in-trim').value = CONFIG.pitch_trim_deg; ui.dispTrim.textContent = CONFIG.pitch_trim_deg.toFixed(1);
    document.getElementById('in-asym').value = CONFIG.asymmetry_factor; ui.dispAsym.textContent = CONFIG.asymmetry_factor.toFixed(2);
    document.getElementById('in-phase').value = CONFIG.phase_shift_deg; ui.dispPhase.textContent = CONFIG.phase_shift_deg.toFixed(0);
    document.getElementById('in-height').value = CONFIG.ride_height; ui.dispHeight.textContent = CONFIG.ride_height.toFixed(2);
    
    // Clear history
    state.liftHistory = []; state.thrustHistory = []; state.powerHistory = []; state.avgPowerHistory = []; state.arithmeticAvgPowerHistory = []; state.avgThrustHistory = []; state.avgLiftHistory = []; state.linearPowerHistory = []; state.rotationalPowerHistory = [];
}

document.getElementById('btn-reset').addEventListener('click', () => {
    state.freq = 1.65; document.getElementById('in-freq').value = 1.65; ui.dispFreq.textContent = "1.65";
    ui.dispPpm.textContent = "99";
    state.heave_amp = 0.13; document.getElementById('in-amp').value = 0.13; ui.dispAmp.textContent = "0.13";
    CONFIG.asymmetry_factor = 0.0; document.getElementById('in-asym').value = 0.0; ui.dispAsym.textContent = "0.00";
    CONFIG.U = 20.0 / 3.6; document.getElementById('in-speed').value = 20.0; ui.dispSpeed.textContent = "20.0";
    CONFIG.mass = 70.0; document.getElementById('in-mass').value = 70; ui.dispMass.textContent = "70";
    CONFIG.S = 0.135; document.getElementById('in-area').value = 1350; ui.dispArea.textContent = "1350";
    CONFIG.AR = 13.9; document.getElementById('in-ar').value = 13.9; ui.dispAr.textContent = "13.9";
    CONFIG.Cd0 = 0.013; document.getElementById('in-cd0').value = 0.013; ui.dispCd0.textContent = "0.013";
    CONFIG.pitch_trim_deg = 3.3; document.getElementById('in-trim').value = 3.3; ui.dispTrim.textContent = "3.3";
    CONFIG.phase_shift_deg = 90.0; document.getElementById('in-phase').value = 90; ui.dispPhase.textContent = "90";
    document.getElementById('lock-phase').checked = true;
    CONFIG.swing_weight_ratio = 0.4; document.getElementById('in-swing').value = 0.4; ui.dispSwing.textContent = "40";
    CONFIG.elastic_efficiency = 1.0; document.getElementById('in-elastic').value = 0; ui.dispElastic.textContent = "0";
    CONFIG.visual_size_m = 0.4; document.getElementById('in-size').value = 0.4; ui.dispSize.textContent = "0.40";
    state.slowMotion = false; document.getElementById('chk-slowmo').checked = false;
    CONFIG.stab_angle = -1.0; document.getElementById('in-stab-angle').value = -1.0; ui.dispStabAngle.textContent = "-1.0";
    CONFIG.S_stab = 0.012; document.getElementById('in-stab-area').value = 120; ui.dispStabArea.textContent = "120";
    CONFIG.AR_stab = 8.0; document.getElementById('in-stab-ar').value = 8.0; ui.dispStabAr.textContent = "8.0";
    CONFIG.fuselage_len = 0.60; document.getElementById('in-fuse-len').value = 0.60; ui.dispFuseLen.textContent = "0.60";
    CONFIG.rider_offset = 0.0; document.getElementById('in-offset').value = 0.0; ui.dispOffset.textContent = "0.00";
    CONFIG.ride_height = 0.20; document.getElementById('in-height').value = 0.20; ui.dispHeight.textContent = "0.20";
    document.getElementById('lock-height').checked = true;
    
    // Clear history for clean restart
    state.liftHistory = []; state.thrustHistory = []; state.powerHistory = []; state.avgPowerHistory = []; state.arithmeticAvgPowerHistory = []; state.avgThrustHistory = []; state.avgLiftHistory = []; state.linearPowerHistory = []; state.rotationalPowerHistory = []; state.gForceHistory = []; state.avgGForceHistory = [];
});

document.getElementById('btn-replay').addEventListener('click', () => {
    state.t = 0;
    state.historyTimer = 0;
    state.liftHistory = [];
    state.thrustHistory = [];
    state.powerHistory = [];
    state.avgPowerHistory = [];
    state.arithmeticAvgPowerHistory = [];
    state.avgThrustHistory = [];
    state.avgLiftHistory = [];
    state.linearPowerHistory = [];
    state.rotationalPowerHistory = [];
    state.gForceHistory = [];
    state.avgGForceHistory = [];
    state.pathX = [];
    state.pathZ = [];
    state.paused = false;
    render({ phys: calculatePhysics(0), avgPower: 0, arithmeticAvgPower: 0, avgThrust: 0, avgLift: 0, avgGForce: 0 });
});

document.getElementById('chk-lift').addEventListener('change', (e) => VISIBILITY.lift = e.target.checked);
document.getElementById('chk-drag').addEventListener('change', (e) => VISIBILITY.drag = e.target.checked);
document.getElementById('chk-rider').addEventListener('change', (e) => VISIBILITY.rider = e.target.checked);
document.getElementById('chk-thrust').addEventListener('change', (e) => VISIBILITY.thrust = e.target.checked);
document.getElementById('chk-assembly').addEventListener('change', (e) => VISIBILITY.assembly = e.target.checked);
document.getElementById('chk-weight').addEventListener('change', (e) => VISIBILITY.weight = e.target.checked);
document.getElementById('chk-net').addEventListener('change', (e) => VISIBILITY.net = e.target.checked);
document.getElementById('chk-stab').addEventListener('change', (e) => VISIBILITY.stab = e.target.checked);
document.getElementById('chk-true-scale').addEventListener('change', (e) => {
    if (e.target.checked) {
        // True Scale (All 0.5)
        CONFIG.scale_L = 0.5; CONFIG.scale_D = 0.5; CONFIG.scale_T = 0.5;
        CONFIG.scale_R = 0.5; CONFIG.scale_N = 0.5; CONFIG.scale_W = 0.5;
        CONFIG.scale_Stab_L = 0.5; CONFIG.scale_Stab_D = 0.5;
    } else {
        // Visible Scale (Exaggerate Drag & Thrust)
        CONFIG.scale_L = 0.5; CONFIG.scale_D = 5.0; CONFIG.scale_T = 1.0;
        CONFIG.scale_R = 0.5; CONFIG.scale_N = 0.5; CONFIG.scale_W = 0.5;
        CONFIG.scale_Stab_L = .5; CONFIG.scale_Stab_D = 10.0;
    }
});

function togglePause() { state.paused = !state.paused; }

function stepForward() {
    if (state.paused) render(updatePhysicsState());
}

function stepBackward() {
    if (state.paused && state.thrustHistory.length > 0) {
        state.liftHistory.pop();
        state.thrustHistory.pop();
        state.powerHistory.pop();
        state.avgPowerHistory.pop();
        state.arithmeticAvgPowerHistory.pop();
        state.avgThrustHistory.pop();
        state.avgLiftHistory.pop();
        state.linearPowerHistory.pop();
        state.rotationalPowerHistory.pop();
        state.gForceHistory.pop();
        state.avgGForceHistory.pop();
        state.pathX.pop();
        state.pathZ.pop();

        state.t -= state.dt;
        state.historyTimer = 0;

        render({ 
            phys: calculatePhysics(state.t), 
            avgPower: state.avgPowerHistory[state.avgPowerHistory.length-1] || 0, 
            arithmeticAvgPower: state.arithmeticAvgPowerHistory[state.arithmeticAvgPowerHistory.length-1] || 0,
            avgThrust: state.avgThrustHistory[state.avgThrustHistory.length-1] || 0,
            avgLift: state.avgLiftHistory[state.avgLiftHistory.length-1] || 0,
            avgGForce: state.avgGForceHistory[state.avgGForceHistory.length-1] || 0
        });
    }
}

document.getElementById('cmd-pause').addEventListener('click', togglePause);
document.getElementById('cmd-rewind').addEventListener('click', stepBackward);
document.getElementById('cmd-forward').addEventListener('click', stepForward);

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') togglePause();
    if (e.code === 'ArrowRight') stepForward();
    if (e.code === 'ArrowLeft') stepBackward();
});

let lastTime = 0;
function loop(timestamp) {
    if (!timestamp) {
        requestAnimationFrame(loop);
        return;
    }
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (!state.paused) {
        const safeDt = Math.min(dt, 0.1);
        const simDt = state.slowMotion ? safeDt * 0.2 : safeDt;
        render(updatePhysicsState(simDt));
    }
    requestAnimationFrame(loop);
}

// --- PRESETS SYSTEM ---
const PRESET_KEY = 'foil_sim_presets';
const DEFAULT_PRESETS = {
    "Standard (80kg)": {
        speed: 17.0, freq: 1.13, amp: 0.18, asym: 0.08, trim: 4.6, phase: 90, height: 0.20,
        mass: 80, area: 1400, ar: 13.9, cd0: 0.013,
        stabArea: 120, stabAr: 8.0, stabAngle: -1.0, fuseLen: 0.60, offset: 0.0,
        swing: 0.4, elastic: 0, size: 0.4
    },
    "Beginner (Slow/Stable)": {
        speed: 15.0, freq: 1.18, amp: 0.18, asym: 0.0, trim: 5.0, phase: 90, height: 0.3,
        mass: 75, area: 1800, ar: 11.5, cd0: 0.018,
        stabArea: 250, stabAr: 6.0, stabAngle: -2.0, fuseLen: 0.70, offset: 0.05,
        swing: 0.4, elastic: 0, size: 0.4
    },
   
    "@foilien": {
        speed: 17.0, freq: 1.12, amp: 0.18, asym: 0.16, trim: 4.5, phase: 90, height: 0.20,
        mass: 80, area: 1300, ar: 13.9, cd0: 0.013,
        stabArea: 120, stabAr: 8.0, stabAngle: -1.0, fuseLen: 0.60, offset: 0.0,
        swing: 0.4, elastic: 0, size: 0.4
    }
};

function getPresets() {
    let presets = JSON.parse(JSON.stringify(DEFAULT_PRESETS));
    try {
        const stored = localStorage.getItem(PRESET_KEY);
        if (stored) {
            const storedPresets = JSON.parse(stored);
            Object.keys(storedPresets).forEach(k => {
                // Only load custom presets from storage to allow code updates to defaults
                if (!DEFAULT_PRESETS[k]) {
                    presets[k] = storedPresets[k];
                }
            });
        }
    } catch(e) { console.error(e); }
    return presets;
}

function savePresets(presets) {
    localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
    renderPresetDropdown();
}

function renderPresetDropdown() {
    const presets = getPresets();
    const sel = document.getElementById('preset-select');
    const current = sel.value;
    sel.innerHTML = '<option value="">-- Load Preset --</option>';
    Object.keys(presets).forEach(k => {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = k;
        sel.appendChild(opt);
    });
    sel.value = current;
}

function captureCurrentState() {
    return {
        speed: parseFloat(document.getElementById('in-speed').value),
        freq: parseFloat(document.getElementById('in-freq').value),
        amp: parseFloat(document.getElementById('in-amp').value),
        asym: parseFloat(document.getElementById('in-asym').value),
        trim: parseFloat(document.getElementById('in-trim').value),
        phase: parseFloat(document.getElementById('in-phase').value),
        height: parseFloat(document.getElementById('in-height').value),
        mass: parseFloat(document.getElementById('in-mass').value),
        area: parseFloat(document.getElementById('in-area').value),
        ar: parseFloat(document.getElementById('in-ar').value),
        cd0: parseFloat(document.getElementById('in-cd0').value),
        stabArea: parseFloat(document.getElementById('in-stab-area').value),
        stabAr: parseFloat(document.getElementById('in-stab-ar').value),
        stabAngle: parseFloat(document.getElementById('in-stab-angle').value),
        fuseLen: parseFloat(document.getElementById('in-fuse-len').value),
        offset: parseFloat(document.getElementById('in-offset').value),
        swing: parseFloat(document.getElementById('in-swing').value),
        elastic: parseFloat(document.getElementById('in-elastic').value),
        size: parseFloat(document.getElementById('in-size').value)
    };
}

function applyPresetState(p) {
    // Update Inputs
    document.getElementById('in-speed').value = p.speed;
    document.getElementById('in-freq').value = p.freq;
    document.getElementById('in-amp').value = p.amp;
    document.getElementById('in-asym').value = p.asym;
    document.getElementById('in-trim').value = p.trim;
    document.getElementById('in-phase').value = p.phase;
    document.getElementById('in-height').value = p.height;
    document.getElementById('in-mass').value = p.mass;
    document.getElementById('in-area').value = p.area;
    document.getElementById('in-ar').value = p.ar;
    document.getElementById('in-cd0').value = p.cd0;
    document.getElementById('in-stab-area').value = p.stabArea;
    document.getElementById('in-stab-ar').value = p.stabAr;
    document.getElementById('in-stab-angle').value = p.stabAngle;
    document.getElementById('in-fuse-len').value = p.fuseLen;
    document.getElementById('in-offset').value = p.offset;
    document.getElementById('in-swing').value = p.swing;
    document.getElementById('in-elastic').value = p.elastic;
    document.getElementById('in-size').value = p.size;

    // Update Config/State
    CONFIG.U = p.speed / 3.6;
    state.freq = p.freq;
    state.heave_amp = p.amp;
    CONFIG.asymmetry_factor = p.asym;
    CONFIG.pitch_trim_deg = p.trim;
    CONFIG.phase_shift_deg = p.phase;
    CONFIG.ride_height = p.height;
    CONFIG.mass = p.mass;
    CONFIG.S = p.area / 10000;
    CONFIG.AR = p.ar;
    CONFIG.Cd0 = p.cd0;
    CONFIG.S_stab = p.stabArea / 10000;
    CONFIG.AR_stab = p.stabAr;
    CONFIG.stab_angle = p.stabAngle;
    CONFIG.fuselage_len = p.fuseLen;
    CONFIG.rider_offset = p.offset;
    CONFIG.swing_weight_ratio = p.swing;
    CONFIG.elastic_efficiency = 1.0 - (p.elastic / 100.0);
    CONFIG.visual_size_m = p.size;

    // Update UI Text
    ui.dispSpeed.textContent = p.speed.toFixed(1);
    ui.dispFreq.textContent = p.freq.toFixed(2);
    ui.dispPpm.textContent = (p.freq * 60).toFixed(0);
    ui.dispAmp.textContent = p.amp.toFixed(2);
    ui.dispAsym.textContent = p.asym.toFixed(2);
    ui.dispTrim.textContent = p.trim.toFixed(1);
    ui.dispPhase.textContent = p.phase.toFixed(0);
    ui.dispHeight.textContent = p.height.toFixed(2);
    ui.dispMass.textContent = p.mass.toFixed(0);
    ui.dispArea.textContent = p.area.toFixed(0);
    ui.dispAr.textContent = p.ar.toFixed(1);
    ui.dispCd0.textContent = p.cd0.toFixed(3);
    ui.dispStabArea.textContent = p.stabArea.toFixed(0);
    ui.dispStabAr.textContent = p.stabAr.toFixed(1);
    ui.dispStabAngle.textContent = p.stabAngle.toFixed(1);
    ui.dispFuseLen.textContent = p.fuseLen.toFixed(2);
    ui.dispOffset.textContent = p.offset.toFixed(2);
    ui.dispSwing.textContent = (p.swing * 100).toFixed(0);
    ui.dispElastic.textContent = p.elastic.toFixed(0);
    ui.dispSize.textContent = p.size.toFixed(2);
    
    // Reset History to avoid graph jumps
    state.liftHistory = []; state.thrustHistory = []; state.powerHistory = []; 
    state.avgPowerHistory = []; state.arithmeticAvgPowerHistory = []; 
    state.avgThrustHistory = []; state.avgLiftHistory = [];
}

document.getElementById('btn-save-preset').addEventListener('click', () => {
    const name = prompt("Name for this preset?");
    if (name) {
        const presets = getPresets();
        presets[name] = captureCurrentState();
        savePresets(presets);
        document.getElementById('preset-select').value = name;
    }
});

document.getElementById('btn-delete-preset').addEventListener('click', () => {
    const sel = document.getElementById('preset-select');
    if (sel.value && confirm("Delete preset '" + sel.value + "'?")) {
        const presets = getPresets();
        delete presets[sel.value];
        savePresets(presets);
    }
});

document.getElementById('btn-download-preset').addEventListener('click', () => {
    const state = captureCurrentState();
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state, null, 2));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "foil_preset.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
});

document.getElementById('btn-upload-preset').addEventListener('click', () => {
    document.getElementById('file-upload-preset').click();
});

document.getElementById('file-upload-preset').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            const name = prompt("Name for imported preset?", file.name.replace('.json',''));
            if(name) {
                const presets = getPresets();
                presets[name] = data;
                savePresets(presets);
                document.getElementById('preset-select').value = name;
                applyPresetState(data);
            }
        } catch(err) {
            console.error(err);
            alert("Invalid JSON file");
        }
    };
    reader.readAsText(file);
    e.target.value = '';
});

document.getElementById('btn-reset-presets').addEventListener('click', () => {
    if (confirm("Reset all presets? This will remove custom saved presets.")) {
        localStorage.removeItem(PRESET_KEY);
        renderPresetDropdown();
    }
});

document.getElementById('preset-select').addEventListener('change', (e) => {
    const val = e.target.value;
    if (val) {
        const presets = getPresets();
        if (presets[val]) {
            applyPresetState(presets[val]);
            document.getElementById('btn-optimize').click();
        }
    }
});

// --- TEST SUITE ---
document.getElementById('btn-tests').addEventListener('click', () => {
    console.clear();
    console.log("%cðŸ§ª STARTING MASTER VALIDATION SUITE (Fixed)...", "color: #2563eb; font-weight: bold; font-size: 16px; margin-bottom: 10px;");
    
    let passCount = 0;
    let failCount = 0;

    // ==========================================
    // 1. HELPER FUNCTIONS
    // ==========================================
    function resetSim() {
        CONFIG.mass = 70; CONFIG.g = 9.81; CONFIG.rho = 1000; CONFIG.S = 0.135; 
        CONFIG.Cd0 = 0.013; CONFIG.AR = 13.9; CONFIG.U = 5.55; 
        
        // State Resets
        state.freq = 0; 
        state.heave_amp = 0; 
        
        // CONFIG Resets (CRITICAL FIXES HERE)
        CONFIG.pitch_trim_deg = 0;
        CONFIG.asymmetry_factor = 0.0; // <--- FIX: Ensure wave is symmetric for tests
        CONFIG.phase_shift_deg = 90.0; // Standard phase
        CONFIG.elastic_efficiency = 1.0;
        
        CONFIG.stab_angle = 0; CONFIG.S_stab = 0; CONFIG.fuselage_len = 0.7; CONFIG.ride_height = 0.2;
    }

    function assert(testName, actual, expected, tolerance = 0.01) {
        if (typeof expected === 'boolean') {
            if (actual === expected) { console.log(`%câœ” PASS: ${testName}`, "color: green"); passCount++; }
            else { console.log(`%câœ˜ FAIL: ${testName}`, "color: red; font-weight: bold"); failCount++; }
            return;
        }
        const diff = Math.abs(actual - expected);
        if (diff <= tolerance) { console.log(`%câœ” PASS: ${testName}`, "color: green"); passCount++; }
        else { console.log(`%câœ˜ FAIL: ${testName}`, "color: red; font-weight: bold"); console.log(`   Expected: ${expected}`); console.log(`   Actual:   ${actual}`); failCount++; }
    }

    // ==========================================
    // 2. BASIC PHYSICS TESTS
    // ==========================================
    console.log("%c--- PHASE 1: AERODYNAMICS ---", "color: #555; font-weight: bold;");

    resetSim(); assert("Static Lift at 0Â° AoA is 0", calculatePhysics(0).Lz, 0);
    
    resetSim(); CONFIG.pitch_trim_deg = 2.0; 
    const expLift = 0.5 * CONFIG.rho * CONFIG.S * ((2 * Math.PI * (2*Math.PI/180)) / (1 + 2/CONFIG.AR)) * (CONFIG.U * CONFIG.U);
    assert(`Lift at 2Â° matches Linear Theory`, calculatePhysics(0).Lz, expLift, 1.0);

    resetSim(); CONFIG.ride_height = 0.2; 
    const k = 1 / (Math.PI * CONFIG.AR); const cl = (2 * Math.PI * (2*Math.PI/180)) / (1 + 2/CONFIG.AR);
    const d_wing = 0.5 * CONFIG.rho * CONFIG.S * (CONFIG.Cd0 + k * cl*cl) * CONFIG.U**2;
    const d_mast = 0.5 * CONFIG.rho * (0.2 * 0.015) * 0.12 * CONFIG.U**2;
    CONFIG.pitch_trim_deg = 2.0; 
    assert(`Total Drag at 2Â° (Wing + Mast)`, Math.abs(calculatePhysics(0).Dx), d_wing + d_mast, 0.5);

    resetSim(); CONFIG.ride_height = 0.2; state.heave_amp = 0.3; 
    assert("Lift drops to 0 when breached", calculatePhysics(0).Lz, 0);

    resetSim(); CONFIG.pitch_trim_deg = 15.0; 
    assert("Stall Flag is TRUE at 15Â°", calculatePhysics(0).isStalled, true);

    resetSim(); CONFIG.S_stab = 0.025; CONFIG.stab_angle = -2.0; 
    assert("Stabilizer generates Downforce (< 0)", calculatePhysics(0).L_stab_z < -1.0, true);

    // ==========================================
    // 3. DYNAMICS TESTS
    // ==========================================
    console.log("%c--- PHASE 2: DYNAMICS & POWER ---", "color: #555; font-weight: bold; margin-top: 10px;");

    // TEST 7 & 8: Kinematics (Now safe from asymmetry)
    resetSim(); state.freq = 1.0; state.heave_amp = 0.5;
    assert("Kinematics: t=0, z = +Amp", calculatePhysics(0).z, 0.5);
    assert("Kinematics: t=0.5, z = -Amp", calculatePhysics(0.5).z, -0.5);

    resetSim(); state.freq = 2.0; state.heave_amp = 0.1;
    assert("Instant Power generated (> 0)", calculatePhysics(0.05).power > 10, true);

    // Test 10: Mass vs Power
    function getTrimmedPower(m) {
        resetSim(); CONFIG.mass = m; state.freq = 1.5; state.heave_amp = 0.20;
        const w = m * 9.81; const q = 0.5 * 1000 * 0.135 * 5.55**2;
        CONFIG.pitch_trim_deg = ((w/q) / ((2*Math.PI)/(1+2/13.9))) * (180/Math.PI);
        let s=0; const steps=50; for(let i=0;i<steps;i++) s+=calculatePhysics(i*0.02).power;
        return s/steps;
    }
    const p60 = getTrimmedPower(60.0); const p80 = getTrimmedPower(80.0);
    assert("Heavier rider requires more Power", p80 > p60, true);

    // ==========================================
    // 4. OPTIMIZER STRESS TEST (100 RUNS)
    // ==========================================
    console.log("%c--- PHASE 3: OPTIMIZER STRESS TEST (100 Runs) ---", "color: #555; font-weight: bold; margin-top: 10px;");
    console.log("   â³ Crunching numbers (this may take 1-2 seconds)...");

    function findBalancedState(runIndex) {
        resetSim();
        const targetLift = CONFIG.mass * CONFIG.g;
        
        state.freq = 1.0 + Math.random();
        state.heave_amp = 0.1 + Math.random()*0.1;
        CONFIG.pitch_trim_deg = Math.random() * 5.0; 
        
        let bestCost = Infinity; let bestPower = Infinity;
        
        for (let i = 0; i < 150; i++) {
            const oldFreq = state.freq; const oldAmp = state.heave_amp; const oldTrim = CONFIG.pitch_trim_deg;
            const scale = Math.max(0.1, 1.0 - (i/150));
            state.freq += (Math.random()-0.5) * 1.0 * scale;
            state.heave_amp += (Math.random()-0.5) * 0.05 * scale;
            CONFIG.pitch_trim_deg += (Math.random()-0.5) * 2.0 * scale;
            
            state.freq = Math.max(0.5, Math.min(2.5, state.freq));
            state.heave_amp = Math.max(0.05, Math.min(0.3, state.heave_amp));
            
            let sL=0, sT=0, sP=0; const steps = 12; const dt = (1.0/state.freq)/steps;
            for(let k=0; k<steps; k++) {
                const p = calculatePhysics(k*dt); sL += p.F_hydro_z; sT += p.thrust; sP += p.power;
            }
            const cost = Math.abs(sL/steps - targetLift) + Math.abs(sT/steps)*3.0 + (sP/steps * 0.01);
            
            if (cost < bestCost) { bestCost = cost; bestPower = sP/steps; } 
            else { state.freq = oldFreq; state.heave_amp = oldAmp; CONFIG.pitch_trim_deg = oldTrim; }
        }
        return { power: bestPower, cost: bestCost, valid: bestCost < 30.0 };
    }

    // --- EXECUTE 100 RUNS ---
    const RUNS = 100;
    let results = [];
    const startTime = performance.now();
    for(let r=0; r<RUNS; r++) results.push(findBalancedState(r));
    const endTime = performance.now();
    console.log(`   â±ï¸ Completed in ${((endTime-startTime)/1000).toFixed(2)}s`);

    results.sort((a,b) => {
        if (a.valid === b.valid) return a.power - b.power; 
        return b.valid - a.valid; 
    });

    console.log("   ðŸ† TOP 20 RESULTS:");
    console.table(results.slice(0, 20).map((r, i) => ({
        Rank: i+1, "Power (W)": r.power.toFixed(1), "Valid?": r.valid ? "YES" : "NO", "Cost": r.cost.toFixed(1)
    })));

    const validRuns = results.filter(r => r.valid).length;
    
    assert(`Optimizer convergence rate (${validRuns}/${RUNS}) >= 50%`, validRuns >= (RUNS/2), true);
    
    if(validRuns > 0) {
        const bestP = results[0].power;
        assert("Best VALID solution is realistic (100W-600W)", (bestP > 100 && bestP < 600), true);
        console.log(`   ðŸ† Absolute Best Power: ${bestP.toFixed(1)} W`);
    } else {
        console.log("%c   âš ï¸ No valid runs found.", "color: orange");
    }

    // ==========================================
    // SUMMARY
    // ==========================================
    console.log("--------------------------------------------------");
    const total = passCount + failCount;
    if (failCount === 0) console.log(`%câœ… SUCCESS: ALL ${passCount} TESTS PASSED.`, "color: green; font-weight: bold; font-size: 16px;");
    else console.log(`%câŒ FAILURE: ${failCount} / ${total} TESTS FAILED.`, "color: red; font-weight: bold; font-size: 16px;");
    
    alert(`Tests Completed. Passed: ${passCount}, Failed: ${failCount}. Check Console for details.`);
});

// Init
renderPresetDropdown();

render({ phys: calculatePhysics(0), avgPower: 0, arithmeticAvgPower: 0, avgThrust: 0, avgLift: 0, avgGForce: 0 });
loop();

</script>
</body>
</html>